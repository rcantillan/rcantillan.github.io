{
  "hash": "afe1ea65ca4c27f25ec855e60f73f269",
  "result": {
    "markdown": "---\ntitle: \"Análisis de Difusión de Identidades Políticas en Redes de Organizaciones\"\nsubtitle: \"Un estudio del conflicto por el Plan Regulador de Peñalolén 2011\"\nauthor: \"Roberto Cantillan\"\ndraft: true\n---\n\n\n## 1. Introducción\n\n### 1.1 Contexto del Estudio\nEl conflicto por el Plan Regulador Comunal de Peñalolén en 2011 representa un caso paradigmático de movilización social en el Chile neoliberal. Este episodio permite analizar cómo emergen identidades políticas a través de la activación de redes organizativas preexistentes.\n\n### 1.2 Marco Teórico\nLa investigación se fundamenta en dos tradiciones teóricas complementarias:\n\n1. **Teoría de Movimientos Sociales** (Diani, 2015):\n   - Los movimientos sociales son modos de coordinación de acción colectiva\n   - Se caracterizan por densas redes informales entre organizaciones\n   - Comparten una identidad colectiva que trasciende eventos específicos\n\n2. **Teoría de la Contienda Política** (Tilly, McAdam, Tarrow):\n   - Énfasis en mecanismos y procesos causales\n   - Importancia de la activación de fronteras identitarias\n   - Rol de brokers en la difusión de marcos interpretativos\n\n### 1.3 Hipótesis\n\n1. **H1:** Las organizaciones políticas de pobladores (OPP) actúan como núcleo del proceso de difusión debido a su alta centralidad y multiplexidad de vínculos.\n\n2. **H2:** La difusión de identidades políticas es más efectiva a través de vínculos que combinan valores compartidos y recursos.\n\n3. **H3:** Los bloques estructurales identificados mediante CONCOR corresponden a dominios de acción colectiva diferenciados pero interconectados.\n\n## 2. Datos y Métodos\n\n### 2.1 Datos\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cargar librerías\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(sna)\nlibrary(network)\n\n# Cargar las matrices de redes desde los archivos CSV\nconf_net <- as.matrix(read.csv(\"datos/ConfianzaNet.csv\", header=FALSE))\ncoop_net <- as.matrix(read.csv(\"datos/CoopNet.csv\", header=FALSE))\nrec_net <-  as.matrix(read.csv(\"datos/RecursosNet.csv\", header=FALSE))\nval_net <-  as.matrix(read.csv(\"datos/ValoresNet.csv\", header=FALSE))\n\n# Cargar atributos\nattr <- read.csv(\"datos/Atributos _org2011.csv\") %>%\n  mutate(\n    bloque_concor = X1PosciónCONCOR,\n    tipo = Tipo,\n    conflictivo = trimws(Orientación) == \"Conflictiva\"\n  )\n\n# Identificar seeds\nseeds <- which(attr$tipo == \"3\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Función para calcular estadísticas descriptivas de redes\nanalyze_networks <- function(networks, names) {\n  map2_dfr(networks, names, ~{\n    tibble(\n      red = .y,\n      densidad = sum(.x > 0)/(nrow(.x)^2),\n      grado_medio = mean(colSums(.x > 0)),\n      reciprocidad = reciprocity(graph_from_adjacency_matrix(.x))\n    )\n  })\n}\n\nnetwork_stats <- analyze_networks(\n  list(conf_net, val_net, coop_net, rec_net),\n  c(\"Confianza\", \"Valores\", \"Cooperación\", \"Recursos\")\n)\n\nprint(network_stats)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n  red         densidad grado_medio reciprocidad\n  <chr>          <dbl>       <dbl>        <dbl>\n1 Confianza     0.0257        1.8         0.349\n2 Valores       0.0267        1.87        0.443\n3 Cooperación   0.0288        2.01        0.440\n4 Recursos      0.0196        1.37        0.229\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nimproved_diffusion_v5 <- function(networks, attributes, seeds,\n                                max_iterations = 100,\n                                convergence_threshold = 0.01,\n                                thresholds = c(0.08, 0.12, 0.15, 0.2)) {\n  \n  # Pesos de las redes según teoría de movimientos sociales (Diani)\n  # Valores y confianza son más importantes para identidad colectiva\n  # Recursos y cooperación para capacidad de movilización\n  weights <- c(0.25, 0.35, 0.15, 0.25) # confianza, valores, cooperación, recursos\n  \n  n_nodes <- nrow(networks[[1]])\n  composite_net <- matrix(0, n_nodes, n_nodes)\n  \n  # Crear red compuesta ponderada\n  for(i in 1:length(networks)) {\n    composite_net <- composite_net + networks[[i]] * weights[i]\n  }\n  \n  # Crear grafo para medidas de centralidad\n  g <- graph_from_adjacency_matrix(composite_net, weighted=TRUE) \n  \n  # Calcular múltiples medidas de centralidad\n  between <- igraph::betweenness(g, normalized=TRUE)\n  flow_bet <- edge_betweenness(g)\n  deg <- igraph::degree(g, normalized=TRUE)\n  eigen <- eigen_centrality(g)$vector\n  close <- igraph::closeness(g, normalized=TRUE)\n  \n  # Score compuesto de influencia organizativa\n  # Incorpora múltiples dimensiones de centralidad\n  org_influence <- scale(between) + \n                  scale(deg) + \n                  scale(eigen) + \n                  scale(close)\n  \n  # Identificar roles organizativos clave (Diani & Tilly)\n  key_orgs <- list(\n    # Brokers: alto between y flow\n    brokers = which(between > quantile(between, 0.8)),\n    \n    # Cores: alto degree y eigenvector\n    movement_cores = which(deg > quantile(deg, 0.8)),\n    \n    # Bridges: alto betweenness pero bajo degree\n    bridges = which(between > quantile(between, 0.8) & \n                   deg < median(deg))\n  )\n  \n  # Calcular multiplexidad de vínculos\n  calc_multiplexity <- function(node) {\n    ties <- sapply(networks, function(x) which(x[node,] > 0))\n    multiplex_ties <- Reduce(intersect, ties)\n    return(length(multiplex_ties))\n  }\n  multiplexity <- sapply(1:n_nodes, calc_multiplexity)\n  \n  # Estados iniciales\n  states <- rep(0, n_nodes)\n  states[seeds] <- 1  # Seeds son OPP\n  states[which(attributes$conflictivo)] <- 1  # Ya conflictivos\n  \n  # Matriz para guardar historia del proceso\n  history <- matrix(0, nrow=max_iterations, ncol=n_nodes)\n  history[1,] <- states\n  \n  # Variables para convergencia\n  recent_changes <- numeric(5)\n  \n  # Proceso de difusión\n  for(iter in 2:max_iterations) {\n    old_states <- states\n    \n    # Para cada nodo no activado\n    for(i in which(states == 0)) {\n      \n      # Calcular influencia por tipo de vínculo\n      influence <- 0\n      total_weight <- 0\n      \n      for(n in 1:length(networks)) {\n        neighbors <- which(networks[[n]][i,] > 0)\n        if(length(neighbors) > 0) {\n          # Influencia base: proporción de vecinos activados\n          net_influence <- sum(states[neighbors]) / length(neighbors)\n          \n          # Bonus por tipo de vínculo\n          if(n == 2) { # Valores compartidos\n            net_influence <- net_influence * 1.2\n          }\n          if(n == 4) { # Recursos compartidos\n            net_influence <- net_influence * 1.1\n          }\n          \n          influence <- influence + net_influence * weights[n]\n          total_weight <- total_weight + weights[n]\n        }\n      }\n      \n      if(total_weight > 0) {\n        influence <- influence / total_weight\n        \n        # Mecanismos de activación basados en teoría\n        \n        # 1. Efecto de brokers (Tilly)\n        if(any(neighbors %in% key_orgs$brokers)) {\n          influence <- influence * 1.3\n        }\n        \n        # 2. Efecto de organizaciones núcleo (Diani)\n        if(any(neighbors %in% key_orgs$movement_cores)) {\n          influence <- influence * 1.2\n        }\n        \n        # 3. Efecto de puentes estructurales\n        if(any(neighbors %in% key_orgs$bridges)) {\n          influence <- influence * 1.1\n        }\n        \n        # 4. Bonus por multiplexidad \n        multiplex_bonus <- 0.15 * multiplexity[i]\n        influence <- influence + multiplex_bonus\n        \n        # Ajuste de umbral según tipo organizativo\n        block <- attributes$bloque_concor[i]\n        if(!is.na(block)) {\n          threshold <- thresholds[block]\n          \n          # Tipos más susceptibles a activación\n          if(attributes$tipo[i] %in% c(2,3,4)) { # OPP, CV y OPB\n            threshold <- threshold * 0.8\n          }\n          \n          # Verificar activación\n          if(influence >= threshold) {\n            states[i] <- 1\n          }\n        }\n      }\n    }\n    \n    # Guardar historia\n    history[iter,] <- states\n    \n    # Verificar convergencia\n    if(all(old_states == states)) break\n    \n    # Calcular tasa de cambio reciente\n    if(iter > 5) {\n      recent_changes <- c(recent_changes[-1], \n                         mean(states) - mean(old_states))\n      if(abs(mean(recent_changes)) < convergence_threshold) break\n    }\n  }\n  \n  # Recortar matriz de historia\n  history <- history[1:iter,]\n  \n  return(list(\n    final_states = states,\n    history = history,\n    n_iterations = iter,\n    key_orgs = key_orgs,\n    composite_net = composite_net,\n    influence_scores = org_influence,\n    multiplexity = multiplexity,\n    converged = iter < max_iterations,\n    final_change_rate = mean(recent_changes)\n  ))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_diffusion_improved <- function(history) {\n  # Asegurarnos que usamos las dimensiones correctas\n  # history es una matriz donde las filas son iteraciones y columnas son nodos\n  prop_activated <- rowMeans(history)  # Promedio por fila en lugar de colSums\n  \n  # Crear dataframe para ggplot\n  df <- data.frame(\n    iteracion = seq_len(length(prop_activated)),\n    proporcion = prop_activated\n  )\n  \n  # Crear visualización\n  ggplot(df, aes(x = iteracion, y = proporcion)) +\n    geom_line(color = \"#2C3E50\", size = 1) +\n    geom_point(color = \"#E74C3C\", size = 2) +\n    theme_minimal() +\n    labs(\n      title = \"Evolución del Proceso de Difusión\",\n      subtitle = paste(\"Proceso convergió en\", nrow(history), \"iteraciones\"),\n      x = \"Iteración\",\n      y = \"Proporción de organizaciones activadas\"\n    ) +\n    theme(\n      plot.title = element_text(face = \"bold\", size = 14),\n      plot.subtitle = element_text(size = 12, color = \"grey40\"),\n      axis.title = element_text(size = 11),\n      panel.grid.minor = element_blank()\n    ) +\n    scale_y_continuous(\n      labels = scales::percent,\n      limits = c(0, 1)\n    ) +\n    geom_hline(\n      yintercept = max(prop_activated), \n      linetype = \"dashed\", \n      color = \"grey50\"\n    ) +\n    annotate(\n      \"text\",\n      x = max(df$iteracion)/2,\n      y = max(prop_activated) + 0.05,\n      label = sprintf(\"Máximo: %.1f%%\", max(prop_activated)*100),\n      color = \"grey40\"\n    )\n}\n\nplot_diffusion_detailed <- function(history, attributes) {\n  # Calcular proporciones por tipo de organización\n  prop_by_type <- apply(history, 1, function(x) {\n    tapply(x, attributes$tipo, mean)\n  }) %>% t() %>% as.data.frame()\n  \n  # Añadir iteración\n  prop_by_type$iteracion <- 1:nrow(prop_by_type)\n  \n  # Convertir a formato largo\n  df_long <- prop_by_type %>%\n    pivot_longer(\n      cols = -iteracion,\n      names_to = \"tipo\",\n      values_to = \"proporcion\"\n    )\n  \n  # Crear visualización\n  ggplot(df_long, aes(x = iteracion, y = proporcion, color = tipo)) +\n    geom_line(size = 1) +\n    geom_point(size = 2) +\n    theme_minimal() +\n    labs(\n      title = \"Evolución de la Difusión por Tipo de Organización\",\n      subtitle = paste(\"Proceso convergió en\", nrow(history), \"iteraciones\"),\n      x = \"Iteración\",\n      y = \"Proporción activada\",\n      color = \"Tipo de organización\"\n    ) +\n    scale_y_continuous(labels = scales::percent) +\n    scale_color_brewer(palette = \"Set2\") +\n    theme(\n      legend.position = \"bottom\",\n      plot.title = element_text(face = \"bold\"),\n      panel.grid.minor = element_blank()\n    )\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ejecutar modelo\nresults <- improved_diffusion_v5(\n  networks = list(conf_net, val_net, coop_net, rec_net),\n  attributes = attr,\n  seeds = seeds\n)\n\n# Visualizar evolución\nplot_diffusion_improved(results$history)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n:::\n\n::: {.cell-output-display}\n![](01_diffusion_files/figure-html/diffusion-patterns-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualizar ambos plots juntos\nlibrary(gridExtra)\ngrid.arrange(\n  plot_diffusion_improved(results$history),\n  plot_diffusion_detailed(results$history, attr),\n  ncol = 2\n)\n```\n\n::: {.cell-output-display}\n![](01_diffusion_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualizar resultados por bloque\nggplot(analysis$block_results, \n       aes(x = as.factor(bloque), \n           y = tasa_adopcion)) +\n  geom_bar(stat = \"identity\") +\n  theme_minimal() +\n  labs(title = \"Tasa de Adopción por Bloque Estructural\")\n\n# Análisis de composición de bloques\nblock_composition <- analysis$diffusion_df %>%\n  group_by(bloque) %>%\n  count(tipo) %>%\n  spread(tipo, n, fill = 0)\n\nprint(block_composition)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identificar y visualizar organizaciones clave\nplot_network_improved(g_composite, attr)\n\n# Análisis de multiplexidad\nprint(analysis$key_orgs)\n```\n:::\n",
    "supporting": [
      "01_diffusion_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}