{
  "hash": "08ecf8cd3f5c4ba2065af1b1e3a9ae75",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Structurally Conditioned Diffusion: A Generalized Framework for Asymmetric Trajectory Channeling in Labor Markets\"\nsubtitle: \"Integrating Piecewise Diffusion Theory with Empirical Analysis of U.S. Skills Data (2015-2023)\"\nauthor: \n  - name: \"Roberto Cantillan & Mauricio Bucca\"\n    affiliations: \n        - name: \"Department of Sociology, PUC\"\n          address: \"Santiago, Chile\"\n\ndate: today\nbibliography: paper_skills_diffusion.bib\nbibliographystyle: apa\ncategories:\n  - R\n  - Diffusion Theory\n  - Polarization\n  - Stratification \n  - Inequality\n  - Labor Markets\n \nimage: \"featured.jpg\"\ntitle-block-banner: featured.jpg\ntitle-block-banner-color: \"rgba(0, 0, 0, 0.8)\"\ntitle-block-style: default\n---\n\n\n\n\n\n# Introduction: From Employer Decisions to Labor Market Structure\n\nThe architecture of inequality in the U.S. labor market is not a static blueprint but an actively reproduced, dynamic process. Its foundations lie in the everyday decisions of **employers within organizations**, who determine which skill requirements to establish for the occupations they manage. Foundational studies have demonstrated that the skill landscape itself is starkly polarized into two distinct domains—a socio-cognitive cluster associated with high wages and a sensory-physical one with low wages [@alabdulkareem_unpacking_2018]—and that this space has a nested, hierarchical architecture [@hosseinioun_skill_2025]. This structural view aligns with recent findings in intergenerational mobility research, which conceptualize occupations not as monolithic categories but as complex bundles of gradational characteristics, where it is often the underlying traits, rather than the job title itself, that are transmitted across generations [@york_gradationalism_2025].\n\nFaced with uncertainty about which skill requirements will maximize productivity or prestige, employers often look to the practices of **other organizations** for guidance. They engage in a process of social learning and imitation, observing how similar organizations define skill requirements for comparable occupations. However, we argue this imitation is not random. It is governed by a powerful, yet poorly understood, mechanism of asymmetric filtering based on the **cultural theorization** of the skill itself. The nature of a skill—how it is socially interpreted and valued—fundamentally alters the pathways it can travel across the occupational status hierarchy as organizations adopt and adapt these requirements.\n\nThe cumulative result of thousands of these guided, micro-level imitation decisions is a macro-level process we term **Asymmetric Trajectory Channeling**. This process actively sorts skills into divergent mobility paths—an upward \"escalator\" for cognitive skills and a \"containment field\" for physical ones—thus deepening labor market stratification from the demand side.\n\nThis study moves beyond describing the consequences of polarization for workers (the supply side) to model the causal mechanisms on the demand side that generate it. By focusing on the rules that guide employer imitation **between organizations**, we explain how structural inequality is not merely a state, but an emergent process reproduced from the ground up through organizational decision-making.\n\n# Theoretical Foundations: From Mimicry to Meaning\n\nEarly studies of diffusion often focused on the spread of a single innovation through a homogenous population. More recent work, however, recognizes that diffusion is fundamentally structured by networks and heterogeneity. Practices do not diffuse randomly or uniformly; they follow patterned trajectories shaped by organizational, cultural, and institutional constraints [@strang_diffusion_1998].\n\n## The Micro-Foundations of Imitation\n\nWe extend this insight by arguing that **employers imitate skill requirements according to fundamentally different logics depending on the type of skill in question**. To understand why, we must first examine the micro-foundations of organizational imitation. The literature suggests three key mechanisms that drive one organization to adopt the practices of another:\n\n1.  **Uncertainty and Bounded Rationality:** Under conditions of uncertainty about the relationship between means and ends, organizations often imitate others as a decision-making shortcut. Rather than calculating an optimal solution from scratch, imitation offers a viable solution with reduced search costs [@cyert_behavioral_2006; @dimaggio_iron_1983].\n\n2.  **Prestige and Status-Seeking:** Imitation is not just a response to uncertainty, but also a strategy to gain legitimacy and status. Organizations do not imitate just anyone; they emulate those they perceive to be more successful or prestigious [@strang_search_2001; @bail_prestige_2019]. This process of \"adaptive emulation\" [@strang_search_2001], driven by \"success stories,\" creates an inherent directional bias in diffusion, where practices flow from high-status to low-status actors.\n\n3.  **Proximity and Network Structure:** Influence is not global but is channeled through social and structural networks. The likelihood that one organization imitates another is strongly conditioned by proximity, whether geographic, social, or cultural [@hedstrom_contagious_1994; @strang_spatial_1993]. Actors are more influenced by their peers, direct competitors, or those with whom they maintain dense relationships.\n\n## A Dual-Process Theory of Skill Diffusion: The Role of Theorization\n\nOur key theoretical innovation is that the **content** of a skill—how it is culturally **theorized** [@strang_institutional_1993]—determines which of these micro-foundations becomes dominant. We argue that organizations filter and evaluate potential practices through two qualitatively different diffusion logics:\n\n* **Cognitive Skills as Portable Assets:** Cognitive skills (analytical, interpersonal, managerial) are theorized as **nested capabilities**: they are abstract, broadly applicable, and perceived as portable assets associated with growth, learning, and adaptability. Under uncertainty, employers look toward **prestigious exemplars** [@strang_learning_2010] that signal success and modernity. As a result, the diffusion of cognitive skills is driven primarily by **aspirational emulation**. They tend to diffuse **upward** through the occupational status hierarchy as organizations seek to imitate their high-status peers.\n\n* **Physical Skills as Context-Dependent Competencies:** In contrast, physical skills (manual, motor) are theorized as **context-dependent competencies**: they are tied to specific material settings, bodily execution, and legacy institutional constraints. They are less likely to be read as generalizable templates for upward mobility. Instead, their diffusion is based on functional rather than aspirational considerations. Therefore, the diffusion of physical skills is governed mainly by **proximity and functional need**, showing less directional bias or even **containment effects** within their current status segments.\n\nThis bifurcation in diffusion logics is what we call **Asymmetric Trajectory Channeling**. While our model, for analytical clarity, uses a binary distinction, we treat skills as **multidimensional bundles** of traits, values, and dispositions [@york_gradationalism_2025]. Employers imitate not just individual skills, but **pieces of occupational identity**.\n\n## Piecewise Dual Process Diffusion Model\n\nTo formalize these dynamics while avoiding multicollinearity issues, we model the **probability** ($P_{i \\to j}^{(c)}$) that an employer, managing a target occupation $j$, adopts a skill of class $c$ by imitating a requirement from a source occupation $i$. This decision is embedded in the macro-level structure of the occupational space.\n\n### Mathematical Formulation\n\nWe define two **non-overlapping** directional status variables that completely separate upward and downward mobility:\n\n$$\n\\Delta^+_{ij} = \\max(0, s_j - s_i) \\quad \\text{(upward status shift)}\n$$\n\n$$\n\\Delta^-_{ij} = \\max(0, s_i - s_j) \\quad \\text{(downward status shift)}\n$$\n\nThe structural form of our **Piecewise Dual Process Model** expresses the diffusion likelihood as:\n\n$$\n\\text{logit}\\, P_{i \\to j}^{(c)} = \\theta_{0c} - \\lambda_c d_{ij} - \\beta_c^+ \\Delta^+_{ij} - \\beta_c^- \\Delta^-_{ij} - \\omega_c w_{ij}\n$$\n\nWhere:\n- $\\theta_{0c}$: baseline propensity to adopt skill class $c$\n- $\\lambda_c$: structural distance penalty parameter\n- $\\beta_c^+$: penalty (or bonus) per unit **upward** status move\n- $\\beta_c^-$: penalty (or bonus) per unit **downward** status move\n- $\\omega_c$: coefficient for wage gap control $w_{ij}$\n\n### Advantages of the Piecewise Specification\n\n1.  **Eliminates Multicollinearity**: Unlike models using both $(s_j - s_i)$ and $|s_j - s_i|$, our piecewise variables are mathematically orthogonal since $\\Delta^+_{ij} \\cdot \\Delta^-_{ij} = 0$ always.\n2.  **Direct Asymmetry Testing**: The difference $(\\beta_c^+ - \\beta_c^-)$ directly measures directional asymmetry without requiring complex transformations.\n3.  **Clear Interpretation**: Each parameter has an unambiguous meaning tied to specific types of status moves.\n\n### Curved Piecewise Extension\n\nFor situations where we expect **nonlinear sensitivity** to status differences, the model can be extended to include curvature terms. We estimate a **generalized linear model** with a **Bernoulli likelihood** and **logit link**. The outcome $y_{ij}^{(c)} \\in \\{0, 1\\}$ indicates whether occupation $j$ adopts a skill of class $c$ from occupation $i$:\n\n$$\ny_{ij}^{(c)} \\sim \\text{Bernoulli}(p_{ij}^{(c)}), \\quad \\text{logit}(p_{ij}^{(c)}) = \\eta_{ij}^{(c)}\n$$\n\nThe predictor is a **second-order polynomial expansion** of upward and downward status gaps:\n\n$$\n\\eta_{ij}^{(c)} =\n\\theta_{0c}\n- \\lambda_c d_{ij}\n- \\beta_{1c}^+ \\Delta^+_{ij}\n- \\beta_{2c}^+ (\\Delta^+_{ij})^2\n- \\beta_{1c}^- \\Delta^-_{ij}\n- \\beta_{2c}^- (\\Delta^-_{ij})^2\n$$\n\n### Prior Choices: Rationale\n\n| Parameter | Description | Prior | Justification |\n|---|---|---|---|\n| $\\theta_{0c}$ (intercept) | Baseline adoption tendency | `normal(0, 5)` | Nearly uninformative; wide enough for coverage |\n| $\\lambda_c$, $\\beta_{1c}^{\\pm}$ | Main distance and status slope terms | `normal(0, 1)` | Weakly informative; encourages shrinkage |\n| $\\beta_{2c}^{\\pm}$ | Curvature terms (quadratic effects) | `double_exponential(0, 0.5)`| **Lasso-type prior** to enable variable selection |\n\nThe **double-exponential (or Laplace) prior** places more mass near 0 than the normal, encouraging sparsity in curvature terms (i.e., it can shrink them toward zero). This is helpful if you're unsure whether curvature is really needed.\n\n\n![](plot_intro.png)\n\n\n# Empirical Analysis\n\n## Data and Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages({\n  library(kableExtra)\n  library(data.table)\n  library(ggplot2)\n  library(broom)\n  library(dplyr)\n  library(scales)\n  library(lmtest)\n  library(knitr)\n  library(patchwork)\n  library(tidyr)\n  library(ggrepel)\n  library(viridis)\n  library(RColorBrewer)\n  library(ggtext)\n  library(brms)\n})\n\n# Custom theme for a professional, academic look\ntheme_paper <- function(base_size = 15, base_family = \"sans\") { \n  theme_minimal(base_size = base_size, base_family = base_family) +\n    theme(\n      text = element_text(color = \"grey20\"),\n      plot.title = element_text(size = rel(1.6), face = \"bold\", hjust = 0.5, margin = margin(b = 15), family = base_family), \n      plot.subtitle = element_markdown(size = rel(1.1), color = \"grey40\", hjust = 0.5, margin = margin(b = 15), lineheight = 1.2), \n      plot.caption = element_text(size = rel(0.9), color = \"grey50\", hjust = 1, margin = margin(t = 12)), \n      axis.title = element_text(size = rel(1.25), face = \"bold\", color = \"grey30\"), \n      axis.text = element_text(size = rel(1.1), color = \"grey40\"), \n      axis.line = element_line(color = \"grey80\", linewidth = 0.6),\n      panel.grid.major = element_line(color = \"grey93\", linewidth = 0.3),\n      panel.grid.minor = element_blank(),\n      panel.border = element_blank(),\n      panel.background = element_rect(fill = \"white\", color = NA),\n      plot.background = element_rect(fill = \"white\", color = NA),\n      legend.title = element_text(size = rel(1.15), face = \"bold\"), \n      legend.text = element_text(size = rel(1.05)), \n      legend.background = element_rect(fill = \"white\", color = \"grey90\"),\n      legend.key = element_rect(fill = \"white\", color = NA),\n      strip.text = element_text(size = rel(1.25), face = \"bold\", color = \"grey20\"), \n      strip.background = element_rect(fill = \"grey97\", color = \"grey80\")\n    )\n}\ntheme_set(theme_paper())\n\n# Define a consistent color palette\ncolor_palette <- c(\"Socio-cognitive\" = \"#0072B2\", \"Socio-technical\" = \"#D55E00\")\n\noutput_dir <- paste0(\"Stratified_Diffusion_Analysis_\", Sys.Date())\nif (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)\n\ncomma <- function(x) format(x, big.mark = \",\", scientific = FALSE)\n```\n:::\n\n\n\n## Data Preparation \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Robust data loading function\nload_and_prepare_data <- function() {\n  data_path <- \"/home/rober/Descargas/all_events_final_enriched.RData\"\n \n  if (file.exists(data_path)) {\n    load(data_path)\n    if (exists(\"all_events_final_enriched\")) {\n      data_for_models <- all_events_final_enriched\n      message(\"Successfully loaded 'all_events_final_enriched'.\")\n    } else {\n      message(\"Warning: 'all_events_final_enriched' not found. Searching for another suitable data object.\")\n      all_objs <- ls()\n      suitable_objects <- all_objs[sapply(all_objs, function(x) {\n        obj <- get(x)\n        (is.data.frame(obj) || is.data.table(obj)) && nrow(obj) > 1000\n      })]\n      if (length(suitable_objects) > 0) {\n        data_for_models <- get(suitable_objects[1])\n        message(paste(\"Using fallback data object:\", suitable_objects[1]))\n      } else {\n        stop(\"No suitable data object found.\")\n      }\n    }\n  } else {\n    stop(paste(\"Data file not found at path:\", data_path))\n  }\n \n  return(data_for_models)\n}\n\n# Load data\ndata_for_models <- load_and_prepare_data()\n```\n:::\n\n\n\n## Variable Construction\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Robust variable mapping\navailable_cols <- names(data_for_models)\n\nrequired_mapping <- list(\n  diffusion = c(\"diffusion\", \"adopt\", \"adoption\", \"outcome\"),\n  structural_distance = c(\"structural_distance\", \"dist\", \"distance\", \"d_ij\"),\n  status_diff = c(\"status_gap_signed\", \"education_diff\", \"status_diff\", \"education_diff_abs\", \"edu_diff\", \"status_gap\"),\n  wage_diff = c(\"wage_gap\", \"wage_diff\", \"wage_distance\"),\n  skill_group = c(\"skill_group_for_model\", \"skill_group\", \"cluster\", \"group\", \"LeidenCluster_2015\", \"skill_cluster_type\"),\n  source_education = c(\"source_education\", \"edu_i\", \"source_edu\", \"soc_source\", \"education_source\"),\n  target_education = c(\"target_education\", \"edu_j\", \"target_edu\", \"soc_target\", \"education_target\"),\n  source_wage = c(\"source_wage\", \"wage_i\", \"wage_source\"),\n  target_wage = c(\"target_wage\", \"wage_j\", \"wage_target\")\n)\n\ncolumn_matches <- sapply(required_mapping, function(p_names) {\n  found <- intersect(p_names, available_cols)\n  if (length(found) > 0) found[1] else NA_character_\n})\n\n# Check for essential columns\nessential_cols <- c(\"diffusion\", \"structural_distance\", \"status_diff\", \"skill_group\")\nif (any(is.na(column_matches[essential_cols]))) {\n  missing_essentials <- names(column_matches[essential_cols][is.na(column_matches[essential_cols])])\n  stop(paste(\"Missing essential columns for model:\", paste(missing_essentials, collapse=\", \")))\n}\n\nif (!is.data.table(data_for_models)) {\n  data_for_models <- as.data.table(data_for_models)\n}\n\ngeneralized_data <- copy(data_for_models)\n\n# Create variables for the model\ngeneralized_data[, `:=`(\n  diffusion = as.numeric(get(column_matches[[\"diffusion\"]])),\n  d_ij = as.numeric(get(column_matches[[\"structural_distance\"]])),\n  status_gap_signed = as.numeric(get(column_matches[[\"status_diff\"]])),\n  skill_group_for_model = as.character(get(column_matches[[\"skill_group\"]]))\n)]\n\n# Create piecewise variables\ngeneralized_data[, `:=`(\n  delta_up = pmax(0, status_gap_signed),      # Δ⁺: upward movements\n  delta_down = pmax(0, -status_gap_signed),  # Δ⁻: downward movements\n  status_gap_magnitude = abs(status_gap_signed)  # Keep for compatibility\n)]\n\n# Handle wage_gap column\nif (\"wage_diff_abs\" %in% names(generalized_data)) {\n  generalized_data[, wage_gap := as.numeric(wage_diff_abs)]\n  message(\"Using 'wage_diff_abs' for wage_gap.\")\n} else if (!is.na(column_matches[[\"wage_diff\"]])) {\n  generalized_data[, wage_gap := as.numeric(get(column_matches[[\"wage_diff\"]]))]\n} else {\n  message(\"Warning: 'wage_diff' column not found. Creating a dummy 'wage_gap' column.\")\n  generalized_data[, wage_gap := 0]\n}\n\n# Add source/target variables\nif (all(c(\"source_Edu_Score_Weighted\", \"target_Edu_Score_Weighted\") %in% names(generalized_data))) {\n  generalized_data[, source_edu := as.numeric(source_Edu_Score_Weighted)]\n  generalized_data[, target_edu := as.numeric(target_Edu_Score_Weighted)]\n  message(\"Using 'source_Edu_Score_Weighted' and 'target_Edu_Score_Weighted' for education variables.\")\n}\n\nif (all(c(\"source_Median_Wage_2015\", \"target_Median_Wage_2023\") %in% names(generalized_data))) {\n  generalized_data[, source_wage := as.numeric(source_Median_Wage_2015)]\n  generalized_data[, target_wage := as.numeric(target_Median_Wage_2023)]\n  message(\"Using 'source_Median_Wage_2015' and 'target_Median_Wage_2023' for wage variables.\")\n}\n\n# Assign content type based on skill group\nif (\"LeidenCluster_2015\" %in% names(generalized_data)) {\n    message(\"Applying specific corrections to 'LeidenCluster_2015' as per original script.\")\n    generalized_data[, LeidenCluster_2015 := as.character(LeidenCluster_2015)]\n    generalized_data[LeidenCluster_2015 == \"NoCluster_2015\", LeidenCluster_2015 := \"LeidenC_1\"]\n    generalized_data <- generalized_data[LeidenCluster_2015 %in% c(\"LeidenC_1\", \"LeidenC_2\")]\n    generalized_data[, content_type := fifelse(LeidenCluster_2015 == \"LeidenC_1\", \"Socio-cognitive\", \"Socio-technical\")]\n} else {\n    message(\"Warning: 'LeidenCluster_2015' not found. Using generic classification.\")\n    unique_skill_groups <- unique(generalized_data$skill_group_for_model)\n    set.seed(42)\n    groups_sorted <- sort(unique_skill_groups)\n    enhancing_groups <- head(groups_sorted, length(groups_sorted) / 2)\n    generalized_data[, content_type := fifelse(skill_group_for_model %in% enhancing_groups, \n                                                \"Socio-cognitive\", \"Socio-technical\")]\n}\n\n# Final data cleaning\ngeneralized_data <- generalized_data[!is.na(content_type)]\ngeneralized_data <- na.omit(generalized_data, \n                                cols = c(\"diffusion\", \"d_ij\", \"delta_up\", \"delta_down\", \"wage_gap\"))\n\n# Verify piecewise variables\nmessage(sprintf(\"Created piecewise variables: delta_up (mean=%.3f), delta_down (mean=%.3f)\", \n                mean(generalized_data$delta_up), mean(generalized_data$delta_down)))\n\n# Fragment data\ncognitive_data <- generalized_data[content_type == \"Socio-cognitive\"]\nphysical_data <- generalized_data[content_type == \"Socio-technical\"]\n```\n:::\n\n\n\n## Descriptive Analysis\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndesc_stats <- generalized_data[, .(\n  N = comma(.N),\n  Diffusion_Rate = sprintf(\"%.1f%%\", mean(diffusion, na.rm = TRUE) * 100),\n  Mean_Distance = sprintf(\"%.3f\", mean(d_ij, na.rm = TRUE)),\n  Mean_Upward_Shift = sprintf(\"%.3f\", mean(delta_up, na.rm = TRUE)),\n  Mean_Downward_Shift = sprintf(\"%.3f\", mean(delta_down, na.rm = TRUE)),\n  Upward_Diffusion_Rate = sprintf(\"%.1f%%\", mean(diffusion[delta_up > 0], na.rm = TRUE) * 100),\n  Downward_Diffusion_Rate = sprintf(\"%.1f%%\", mean(diffusion[delta_down > 0], na.rm = TRUE) * 100)\n), by = content_type]\n\nkable(desc_stats, \n      caption = \"**Table 1: Descriptive Statistics by Skill Content Type**\",\n      col.names = c(\"Content Type\", \"N\", \"Diffusion Rate\", \"Mean Distance\", \n                    \"Mean Δ⁺\", \"Mean Δ⁻\", \"Upward Diffusion\", \"Downward Diffusion\")) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>**Table 1: Descriptive Statistics by Skill Content Type**</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Content Type </th>\n   <th style=\"text-align:left;\"> N </th>\n   <th style=\"text-align:left;\"> Diffusion Rate </th>\n   <th style=\"text-align:left;\"> Mean Distance </th>\n   <th style=\"text-align:left;\"> Mean Δ⁺ </th>\n   <th style=\"text-align:left;\"> Mean Δ⁻ </th>\n   <th style=\"text-align:left;\"> Upward Diffusion </th>\n   <th style=\"text-align:left;\"> Downward Diffusion </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Socio-cognitive </td>\n   <td style=\"text-align:left;\"> 353,988 </td>\n   <td style=\"text-align:left;\"> 26.8% </td>\n   <td style=\"text-align:left;\"> 0.679 </td>\n   <td style=\"text-align:left;\"> 1.161 </td>\n   <td style=\"text-align:left;\"> 0.773 </td>\n   <td style=\"text-align:left;\"> 37.5% </td>\n   <td style=\"text-align:left;\"> 13.6% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Socio-technical </td>\n   <td style=\"text-align:left;\"> 318,951 </td>\n   <td style=\"text-align:left;\"> 27.0% </td>\n   <td style=\"text-align:left;\"> 0.675 </td>\n   <td style=\"text-align:left;\"> 1.512 </td>\n   <td style=\"text-align:left;\"> 0.294 </td>\n   <td style=\"text-align:left;\"> 27.0% </td>\n   <td style=\"text-align:left;\"> 27.1% </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n**Table 1 Interpretation:** This table summarizes the key variables for the two skill types. We observe that socio-cognitive skills have a slightly higher overall diffusion rate. Notably, for both types, the diffusion rate is higher for upward status shifts (Δ⁺ > 0) than for downward shifts (Δ⁻ > 0), providing initial evidence of an aspirational bias in skill adoption.\n\n## Descriptive Visualizations\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_descriptive_coherent_style <- function(data) {\n  \n  # Trabajar con data.table\n  if (!is.data.table(data)) {\n    dt <- as.data.table(data)\n  } else {\n    dt <- copy(data)\n  }\n  \n  # Verificar columnas\n  required_cols <- c(\"status_gap_signed\", \"content_type\", \"diffusion\")\n  missing_cols <- required_cols[!required_cols %in% names(dt)]\n  \n  if (length(missing_cols) > 0) {\n    stop(\"Missing required columns: \", paste(missing_cols, collapse = \", \"))\n  }\n  \n  # Crear movement_type\n  dt[, movement_type := fcase(\n    status_gap_signed < -0.5, \"Downward\",\n    abs(status_gap_signed) <= 0.5, \"Lateral\",\n    status_gap_signed > 0.5, \"Upward\",\n    default = NA_character_\n  )]\n  \n  # Filtrar datos válidos\n  dt_clean <- dt[!is.na(movement_type) & !is.na(content_type)]\n  \n  # Calcular estadísticas\n  summary_stats <- dt_clean[, .(\n    diffusion_rate = mean(diffusion, na.rm = TRUE),\n    n = .N\n  ), by = .(movement_type, content_type)]\n  \n  # Calcular intervalos de confianza\n  summary_stats[, `:=`(\n    se = sqrt(diffusion_rate * (1 - diffusion_rate) / n),\n    ci_lower = pmax(0, diffusion_rate - 1.96 * sqrt(diffusion_rate * (1 - diffusion_rate) / n)),\n    ci_upper = pmin(1, diffusion_rate + 1.96 * sqrt(diffusion_rate * (1 - diffusion_rate) / n))\n  )]\n  \n  # Convertir a data.frame y ordenar\n  summary_df <- as.data.frame(summary_stats)\n  summary_df$movement_type <- factor(summary_df$movement_type, \n    levels = c(\"Downward\", \"Lateral\", \"Upward\"))\n  \n  # Mismos colores que el plot de líneas\n  coherent_colors <- c(\n    \"Socio-cognitive\" = \"#1f77b4\",  # Azul coherente\n    \"Socio-technical\" = \"#ff7f0e\"   # Naranja coherente\n  )\n  \n  # Crear el plot con el mismo estilo\n  p <- ggplot(summary_df, aes(x = movement_type, y = diffusion_rate, fill = content_type)) +\n    \n    # Área sombreada sutil para destacar el escalator effect\n    annotate(\"rect\", xmin = 2.5, xmax = 3.5, ymin = -Inf, ymax = Inf, \n             fill = \"#E8F4FD\", alpha = 0.3) +  # Azul muy claro\n    \n    # Barras principales\n    geom_col(position = position_dodge(0.8), \n             width = 0.7,\n             color = \"white\", \n             linewidth = 0.8,\n             alpha = 0.85) +\n    \n    # Barras de error elegantes\n    geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), \n                  position = position_dodge(0.8), \n                  width = 0.25, \n                  linewidth = 1,\n                  color = \"grey40\") +\n    \n    # Etiquetas de porcentaje\n    geom_text(aes(label = paste0(round(diffusion_rate * 100, 1), \"%\")), \n              position = position_dodge(0.8), \n              vjust = -0.6, \n              size = 5, \n              fontface = \"bold\",\n              color = \"grey20\") +\n    \n    # Flecha sutil llamando atención al escalator effect\n    annotate(\"segment\", \n             x = 2.7, xend = 3.3, \n             y = 0.42, yend = 0.42, \n             arrow = arrow(length = unit(0.3, \"cm\"), type = \"closed\"), \n             color = \"#1f77b4\", \n             linewidth = 2,\n             alpha = 0.8) +\n    \n    # Texto explicativo sutil\n    annotate(\"text\", \n             x = 3, y = 0.45, \n             label = \"ESCALATOR\\nEFFECT\", \n             color = \"#1f77b4\", \n             fontface = \"bold\", \n             size = 4, \n             hjust = 0.5,\n             lineheight = 0.9) +\n    \n    # Escalas coherentes con el estilo\n    scale_fill_manual(values = coherent_colors, name = \"Skill Type:\") +\n    scale_y_continuous(\n      limits = c(0, 0.5),\n      breaks = seq(0, 0.5, 0.1),\n      expand = expansion(mult = c(0, 0.05)),\n      labels = function(x) paste0(x*100, \"%\")\n    ) +\n    scale_x_discrete(\n      labels = c(\"Downward\\n(High → Low)\", \"Lateral\\n(Similar Status)\", \"Upward\\n(Low → High)\")\n    ) +\n    \n    # Etiquetas coherentes\n    labs(\n      title = \"Raw Data Reveals Asymmetric Trajectory Channeling\",\n      subtitle = \"Descriptive evidence for differential skill mobility patterns by content type\",\n      x = \"Status Movement Direction\",\n      y = \"Observed Skill Adoption Rate\"\n    ) +\n    \n    # MISMO TEMA que el plot de líneas\n    theme_minimal(base_size = 15) +\n    theme(\n      # Mismo fondo gris\n      plot.background = element_rect(fill = \"white\", color = NA),\n      panel.background = element_rect(fill = \"white\", color = NA),\n      \n      # Grid sutil igual al original\n      panel.grid.major = element_line(color = \"white\", linewidth = 0.6),\n      panel.grid.minor = element_line(color = \"white\", linewidth = 0.3),\n      \n      # Sin bordes para mantener coherencia\n      panel.border = element_blank(),\n      axis.line = element_line(color = \"grey40\", linewidth = 0.5),\n      \n      # Títulos coherentes\n      plot.title = element_text(\n        size = 18, \n        face = \"bold\", \n        hjust = 0.5, \n        color = \"grey20\",\n        margin = margin(b = 8)\n      ),\n      plot.subtitle = element_text(\n        size = 14, \n        hjust = 0.5, \n        color = \"grey40\",\n        margin = margin(b = 20)\n      ),\n      \n      # Ejes coherentes\n      axis.title.x = element_text(\n        size = 15, \n        color = \"grey30\", \n        margin = margin(t = 10)\n      ),\n      axis.title.y = element_text(\n        size = 15, \n        color = \"grey30\", \n        margin = margin(r = 10)\n      ),\n      axis.text = element_text(\n        size = 15, \n        color = \"grey40\"\n      ),\n      axis.ticks = element_line(color = \"grey50\", linewidth = 0.4),\n      \n      # Leyenda coherente\n      legend.position = \"bottom\",\n      legend.background = element_rect(fill = \"white\", color = NA),\n      legend.text = element_text(size = 14, color = \"black\"),\n      legend.title = element_text(size = 12, face = \"bold\", color = \"black\"),\n      legend.key.size = unit(1, \"cm\"),\n      legend.margin = margin(t = 15),\n      \n      # Márgenes coherentes\n      plot.margin = margin(20, 20, 15, 20)\n    ) +\n    \n    # Guías de leyenda coherentes\n    guides(\n      fill = guide_legend(\n        title.position = \"left\",\n        nrow = 1,\n        keywidth = unit(1.2, \"cm\"),\n        keyheight = unit(0.8, \"cm\")\n      )\n    )\n  \n  return(p)\n}\n\n# Crear el gráfico con estilo coherente\nfig_coherent_bars <- create_descriptive_coherent_style(generalized_data)\nprint(fig_coherent_bars)\n```\n\n::: {.cell-output-display}\n![](01_model_files/figure-html/plot-functions-1.png){width=3600}\n:::\n:::\n\n\n\n\n# Model Specification and Estimation\n\n## Piecewise Dual Process Models\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Formula for the standard linear piecewise model\nformula_piecewise <- diffusion ~ d_ij + delta_up + delta_down + wage_gap\n```\n:::\n\n\n\n## Separate Model Estimation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Estimate separate models for each skill type\nmodel_cognitive_piecewise <- glm(formula_piecewise, data = cognitive_data, family = binomial(link = \"logit\"))\nmodel_physical_piecewise <- glm(formula_piecewise, data = physical_data, family = binomial(link = \"logit\"))\n```\n:::\n\n\n\n## Parameter Extraction and Comparison\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to extract parameters from GLM models\nextract_piecewise_parameters <- function(model, skill_type, data_subset) {\n  coefs <- coef(model)\n \n  get_param <- function(name, default_val = 0) if (name %in% names(coefs)) coefs[name] else default_val\n\n  return(list(\n    skill_type = skill_type,\n    n_obs = nrow(data_subset),\n    lambda_hat = get_param(\"d_ij\"),              \n    beta_up_hat = get_param(\"delta_up\"),         \n    beta_down_hat = get_param(\"delta_down\"),     \n    wage_hat = get_param(\"wage_gap\"),            \n    asymmetry = get_param(\"delta_up\") - get_param(\"delta_down\"),  \n    aic = AIC(model),\n    mcfadden_r2 = 1 - (model$deviance / model$null.deviance)\n  ))\n}\n\nparams_cognitive_pw <- extract_piecewise_parameters(model_cognitive_piecewise, \"Socio-cognitive\", cognitive_data)\nparams_physical_pw <- extract_piecewise_parameters(model_physical_piecewise, \"Socio-technical\", physical_data)\n```\n:::\n\n\n\n# Statistical Tests and Model Comparison\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a comparison table for the piecewise models\npiecewise_comparison <- data.frame(\n  `Skill Type` = c(\"Socio-cognitive\", \"Socio-technical\"),\n  N = c(comma(params_cognitive_pw$n_obs), comma(params_physical_pw$n_obs)),\n  `λ (Distance)` = c(params_cognitive_pw$lambda_hat, params_physical_pw$lambda_hat),\n  `β⁺ (Upward)` = c(params_cognitive_pw$beta_up_hat, params_physical_pw$beta_up_hat),\n  `β⁻ (Downward)` = c(params_cognitive_pw$beta_down_hat, params_physical_pw$beta_down_hat),\n  `Asymmetry (β⁺ - β⁻)` = c(params_cognitive_pw$asymmetry, params_physical_pw$asymmetry),\n  `McFadden's R²` = c(params_cognitive_pw$mcfadden_r2, params_physical_pw$mcfadden_r2),\n  AIC = c(params_cognitive_pw$aic, params_physical_pw$aic),\n  check.names = FALSE\n)\n\nkable(piecewise_comparison,\n      caption = \"**Table 2: Frequentist Piecewise Model Results**\",\n      digits = 4) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = TRUE) %>%\n  column_spec(6, bold = TRUE, background = \"#F0F8FF\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>**Table 2: Frequentist Piecewise Model Results**</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Skill Type </th>\n   <th style=\"text-align:left;\"> N </th>\n   <th style=\"text-align:right;\"> λ (Distance) </th>\n   <th style=\"text-align:right;\"> β⁺ (Upward) </th>\n   <th style=\"text-align:right;\"> β⁻ (Downward) </th>\n   <th style=\"text-align:right;\"> Asymmetry (β⁺ - β⁻) </th>\n   <th style=\"text-align:right;\"> McFadden's R² </th>\n   <th style=\"text-align:right;\"> AIC </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Socio-cognitive </td>\n   <td style=\"text-align:left;\"> 353,988 </td>\n   <td style=\"text-align:right;\"> 1.1178 </td>\n   <td style=\"text-align:right;\"> 0.4440 </td>\n   <td style=\"text-align:right;\"> -0.2582 </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 248, 255, 255) !important;\"> 0.7022 </td>\n   <td style=\"text-align:right;\"> 0.1206 </td>\n   <td style=\"text-align:right;\"> 362128.6 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Socio-technical </td>\n   <td style=\"text-align:left;\"> 318,951 </td>\n   <td style=\"text-align:right;\"> 2.5693 </td>\n   <td style=\"text-align:right;\"> -0.1216 </td>\n   <td style=\"text-align:right;\"> -0.2251 </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 248, 255, 255) !important;\"> 0.1035 </td>\n   <td style=\"text-align:right;\"> 0.0129 </td>\n   <td style=\"text-align:right;\"> 367436.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n**Table 2 Interpretation:** The frequentist models confirm the descriptive findings. Both skill types are penalized by structural distance (negative λ). However, the key result is in the **Asymmetry** column. Socio-cognitive skills have a large, positive asymmetry coefficient (0.7022), indicating that upward status moves are strongly favored over downward moves. In contrast, socio-technical skills have a much smaller asymmetry value (0.1035), suggesting a more neutral response to the direction of status change.\n\n## Model Predictions & Visualization\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_piecewise_predictions <- function(model_cog, model_phys, data_cog, data_phys, n_points = 150) {\n \n  baseline_distance_cog <- median(data_cog$d_ij, na.rm = TRUE)\n  baseline_wage_cog <- median(data_cog$wage_gap, na.rm = TRUE)\n\n  baseline_distance_phys <- median(data_phys$d_ij, na.rm = TRUE)\n  baseline_wage_phys <- median(data_phys$wage_gap, na.rm = TRUE)\n \n  # Create status range for predictions\n  status_range <- seq(-4, 4, length.out = n_points)\n \n  # Convert to piecewise variables\n  delta_up_range <- pmax(0, status_range)\n  delta_down_range <- pmax(0, -status_range)\n \n  pred_data_cognitive <- data.frame(\n    delta_up = delta_up_range,\n    delta_down = delta_down_range,\n    d_ij = baseline_distance_cog,\n    wage_gap = baseline_wage_cog\n  )\n  pred_cognitive <- predict(model_cog, newdata = pred_data_cognitive, type = \"response\")\n \n  pred_data_physical <- data.frame(\n    delta_up = delta_up_range,\n    delta_down = delta_down_range,\n    d_ij = baseline_distance_phys,\n    wage_gap = baseline_wage_phys\n  )\n  pred_physical <- predict(model_phys, newdata = pred_data_physical, type = \"response\")\n \n  predictions <- rbind(\n    data.frame(status_gap = status_range, probability = pred_cognitive, content_type = \"Socio-cognitive\"),\n    data.frame(status_gap = status_range, probability = pred_physical, content_type = \"Socio-technical\")\n  )\n \n  return(predictions)\n}\n\n# Generate predictions from the frequentist models\npiecewise_predictions <- generate_piecewise_predictions(model_cognitive_piecewise, model_physical_piecewise, cognitive_data, physical_data)\n\n# Define the equation string for the plot subtitle\nequation_str <- \"logit(P) = &theta;<sub>0</sub> - &lambda;d - &beta;<sup>+</sup>&Delta;<sup>+</sup> - &beta;<sup>-</sup>&Delta;<sup>-</sup>\"\n\np_main_piecewise <- ggplot(piecewise_predictions, aes(x = status_gap, y = probability, color = content_type)) +\n  geom_line(linewidth = 1.8, alpha = 0.9) +\n  geom_vline(xintercept = 0, linetype = \"dashed\", alpha = 0.7, color = \"gray50\") +\n  scale_color_manual(values = color_palette, name = \"Skill Type:\") +\n  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +\n  annotate(\"text\", x = 2.5, y = max(piecewise_predictions$probability) * 0.85, \n           label = \"ASPIRATIONAL PULL\\n(Low-to-High Status)\", \n           hjust = 0.5, size = 4.5, color = \"gray30\", fontface = \"bold\") +\n  annotate(\"text\", x = -2.5, y = max(piecewise_predictions$probability) * 0.85, \n           label = \"CONTAINMENT\\n(High-to-Low Status)\", \n           hjust = 0.5, size = 4.5, color = \"gray30\", fontface = \"bold\") +\n  labs(\n    title = \"Asymmetric Trajectory Channeling: Evidence from Piecewise Models\",\n    subtitle = paste(\"Model:\", equation_str),\n    x = \"Educational Status Gap (Destination - Source)\",\n    y = \"Predicted Skill Diffusion Probability\"\n  ) +\n  theme_paper() +\n  theme(\n    legend.position = \"bottom\",\n    plot.subtitle = element_markdown(size = rel(1.2))\n  )\n\nprint(p_main_piecewise)\n```\n\n::: {.cell-output-display}\n![](01_model_files/figure-html/main-visualization-1.png){width=3600}\n:::\n:::\n\n\n\n**Figure 3 Interpretation:** This plot visualizes the core finding from the frequentist models. The steep upward slope for socio-cognitive skills (blue) for positive status gaps (x-axis > 0) illustrates a strong \"aspirational pull.\" Conversely, the flatter curve for socio-technical skills (red) demonstrates their relative indifference to status-gaining imitation, highlighting the \"Asymmetric Trajectory Channeling\" effect.\n\n# Advanced Bayesian Analysis (with Curvature Selection)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(\"🚀 ADVANCED BAYESIAN SETUP - Non-Linear Model with Shrinkage Priors\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n🚀 ADVANCED BAYESIAN SETUP - Non-Linear Model with Shrinkage Priors\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"====================================================================\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n====================================================================\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"OBJECTIVE: Estimate curvature effects using Laplace (Lasso) priors.\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOBJECTIVE: Estimate curvature effects using Laplace (Lasso) priors.\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"METHOD: High-quality Hamiltonian Monte Carlo (HMC) on a large sample.\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMETHOD: High-quality Hamiltonian Monte Carlo (HMC) on a large sample.\n```\n\n\n:::\n\n```{.r .cell-code}\n# 1. Subsample data for a balance of speed and robustness\nset.seed(123)\nsample_size <- 50000\n\ncognitive_data_sample <- if (nrow(cognitive_data) > sample_size) {\n  cognitive_data[sample(.N, sample_size)]\n} else {\n  cognitive_data\n}\n\nphysical_data_sample <- if (nrow(physical_data) > sample_size) {\n  physical_data[sample(.N, sample_size)]\n} else {\n  physical_data\n}\n\nmessage(sprintf(\"Subsampling for HMC. Using %s cognitive and %s physical observations.\",\n                comma(nrow(cognitive_data_sample)),\n                comma(nrow(physical_data_sample))))\n\n# 2. Prepare polynomial terms\ncognitive_data_sample <- cognitive_data_sample %>%\n  mutate(\n    delta_up2   = delta_up^2,\n    delta_down2 = delta_down^2\n  )\n\nphysical_data_sample <- physical_data_sample %>%\n  mutate(\n    delta_up2   = delta_up^2,\n    delta_down2 = delta_down^2\n  )\n\n# 3. Non-linear model formula (no underscores in parameter names)\nformula_nonlinear <- bf(\n  diffusion ~ theta0 - lambda * d_ij - beta1up * delta_up - beta2up * delta_up2 - beta1down * delta_down - beta2down * delta_down2,\n  theta0 + lambda + beta1up + beta2up + beta1down + beta2down ~ 1,\n  nl = TRUE\n)\n\n# 4. Prior specification (using double_exponential)\npriors_lasso <- c(\n  prior(normal(0, 5), nlpar = \"theta0\"),\n  prior(normal(0, 1), nlpar = \"lambda\", lb = 0), \n  prior(normal(0, 1), nlpar = \"beta1up\"),\n  prior(normal(0, 1), nlpar = \"beta1down\"),\n  prior(double_exponential(0, 0.5), nlpar = \"beta2up\"),\n  prior(double_exponential(0, 0.5), nlpar = \"beta2down\")\n)\n\nstart_hmc_time <- Sys.time()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# =============================================================================\n# HIGH-QUALITY FITTING FUNCTION FOR ADVANCED MODEL USING HMC\n# =============================================================================\n\nfit_advanced_hmc_model <- function(formula, data, model_name, priors) {\n \n  cat(sprintf(\"\\n🚀 ADVANCED FITTING (HMC): %s\\n\", toupper(model_name)))\n  cat(\"=\" %>% rep(50) %>% paste(collapse = \"\"), \"\\n\")\n  cat(sprintf(\"📊 Using %s observations from sample.\\n\", comma(nrow(data))))\n  cat(\"⚙️ Algorithm: Hamiltonian Monte Carlo (NUTS Sampler).\\n\")\n \n  start_time <- Sys.time()\n  model <- NULL\n \n  tryCatch({\n    model <- brm(\n      formula = formula,\n      data = data,\n      prior = priors,\n      family = bernoulli(),\n      chains = 2,\n      cores = 4,\n      iter = 1000,\n      warmup = 500,\n      seed = 42,\n      silent = 0,\n      control = list(adapt_delta = 0.9)\n    )\n    cat(\"✅ Advanced HMC model fitted successfully.\\n\")\n  }, error = function(e) {\n    cat(\"❌ ERROR during advanced model fitting:\\n\")\n    cat(e$message, \"\\n\")\n  })\n \n  end_time <- Sys.time()\n  time_elapsed <- difftime(end_time, start_time, units = \"secs\")\n  cat(sprintf(\"⏱️ Fitting time: %.1f seconds.\\n\", time_elapsed))\n \n  return(list(model = model, time = time_elapsed))\n}\n\n# =============================================================================\n# FIT MODELS WITH ADVANCED CONFIGURATION\n# =============================================================================\n\n# ADVANCED COGNITIVE MODEL\nresults_cognitive_advanced <- fit_advanced_hmc_model(\n  formula = formula_nonlinear,\n  data = cognitive_data_sample,\n  model_name = \"cognitive_advanced_hmc\",\n  priors = priors_lasso\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n🚀 ADVANCED FITTING (HMC): COGNITIVE_ADVANCED_HMC\n================================================== \n📊 Using 50,000 observations from sample.\n⚙️ Algorithm: Hamiltonian Monte Carlo (NUTS Sampler).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✅ Advanced HMC model fitted successfully.\n⏱️ Fitting time: 2852.7 seconds.\nation took 0.109476 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 1094.76 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 2: \nChain 2: Gradient evaluation took 0.13411 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 1341.1 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 1: Iteration:   1 / 1000 [  0%]  (Warmup)\nChain 2: Iteration:   1 / 1000 [  0%]  (Warmup)\nChain 1: Iteration: 100 / 1000 [ 10%]  (Warmup)\nChain 1: Iteration: 200 / 1000 [ 20%]  (Warmup)\nChain 2: Iteration: 100 / 1000 [ 10%]  (Warmup)\nChain 1: Iteration: 300 / 1000 [ 30%]  (Warmup)\nChain 1: Iteration: 400 / 1000 [ 40%]  (Warmup)\nChain 2: Iteration: 200 / 1000 [ 20%]  (Warmup)\nChain 1: Iteration: 500 / 1000 [ 50%]  (Warmup)\nChain 1: Iteration: 501 / 1000 [ 50%]  (Sampling)\nChain 2: Iteration: 300 / 1000 [ 30%]  (Warmup)\nChain 1: Iteration: 600 / 1000 [ 60%]  (Sampling)\nChain 2: Iteration: 400 / 1000 [ 40%]  (Warmup)\nChain 1: Iteration: 700 / 1000 [ 70%]  (Sampling)\nChain 2: Iteration: 500 / 1000 [ 50%]  (Warmup)\nChain 2: Iteration: 501 / 1000 [ 50%]  (Sampling)\nChain 1: Iteration: 800 / 1000 [ 80%]  (Sampling)\nChain 2: Iteration: 600 / 1000 [ 60%]  (Sampling)\nChain 1: Iteration: 900 / 1000 [ 90%]  (Sampling)\nChain 2: Iteration: 700 / 1000 [ 70%]  (Sampling)\nChain 1: Iteration: 1000 / 1000 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 1447.14 seconds (Warm-up)\nChain 1:                1060.98 seconds (Sampling)\nChain 1:                2508.12 seconds (Total)\nChain 1: \nChain 2: Iteration: 800 / 1000 [ 80%]  (Sampling)\nChain 2: Iteration: 900 / 1000 [ 90%]  (Sampling)\nChain 2: Iteration: 1000 / 1000 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 1877.97 seconds (Warm-up)\nChain 2:                890.753 seconds (Sampling)\nChain 2:                2768.72 seconds (Total)\nChain 2: \n```\n\n\n:::\n\n```{.r .cell-code}\n# ADVANCED PHYSICAL MODEL\nresults_physical_advanced <- fit_advanced_hmc_model(\n  formula = formula_nonlinear,\n  data = physical_data_sample,\n  model_name = \"physical_advanced_hmc\",\n  priors = priors_lasso\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n%]  (Sampling)\nChain 2: Iteration: 900 / 1000 [ 90%]  (Sampling)\nChain 2: Iteration: 1000 / 1000 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 1359.17 seconds (Warm-up)\nChain 2:                636.56 seconds (Sampling)\nChain 2:                1995.73 seconds (Total)\nChain 2: \n```\n\n\n:::\n\n```{.r .cell-code}\nend_hmc_time <- Sys.time()\ntotal_analysis_time <- difftime(end_hmc_time, start_hmc_time, units = \"secs\")\n\ncat(\"\\n🏁 ADVANCED ANALYSIS COMPLETE\\n\")\ncat(\"=====================================\\n\")\ncat(sprintf(\"⏱️ Total analysis time: %.1f seconds\\n\", total_analysis_time))\n\nall_success_advanced <- !is.null(results_cognitive_advanced$model) && !is.null(results_physical_advanced$model)\n\nif(all_success_advanced) {\n  cat(\"✅ Both advanced models fitted successfully.\\n\")\n} else {\n  cat(\"❌ Error in fitting one or more advanced models.\\n\")\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# =============================================================================\n# PARAMETER EXTRACTION (ADVANCED MODEL)\n# =============================================================================\n\nif(all_success_advanced) {\n  cat(\"\\n🔍 EXTRACTING PARAMETERS FROM ADVANCED MODEL...\\n\")\n  cat(\"=\" %>% rep(55) %>% paste(collapse = \"\"), \"\\n\")\n \n  # Extract posterior draws\n  posterior_cog_advanced <- as_draws_df(results_cognitive_advanced$model)\n  posterior_phys_advanced <- as_draws_df(results_physical_advanced$model)\n \n  # Correct parameter names based on brms output for non-linear models\n  required_cols <- c(\"b_beta1up_Intercept\", \"b_beta1down_Intercept\")\n  \n  if (all(required_cols %in% names(posterior_cog_advanced)) && all(required_cols %in% names(posterior_phys_advanced))) {\n      # Asymmetry parameters (based on linear terms)\n      asymmetry_cog_advanced <- posterior_cog_advanced$b_beta1up_Intercept - posterior_cog_advanced$b_beta1down_Intercept\n      asymmetry_phys_advanced <- posterior_phys_advanced$b_beta1up_Intercept - posterior_phys_advanced$b_beta1down_Intercept\n      asymmetry_diff_advanced <- asymmetry_cog_advanced - asymmetry_phys_advanced\n     \n      # Statistics\n      prob_hypothesis_advanced <- mean(asymmetry_diff_advanced > 0, na.rm = TRUE)\n      effect_size_advanced <- median(asymmetry_diff_advanced, na.rm = TRUE)\n      ci_95_advanced <- quantile(asymmetry_diff_advanced, c(0.025, 0.975), na.rm = TRUE)\n      \n      cat(\"🎯 PRELIMINARY RESULTS (ADVANCED MODEL):\\n\")\n      cat(\"=\" %>% rep(45) %>% paste(collapse = \"\"), \"\\n\")\n      cat(sprintf(\"• P(asymmetry_cog > asymmetry_phys): %.2f%%\\n\", prob_hypothesis_advanced * 100))\n      cat(sprintf(\"• Median Asymmetry Difference: %.4f\\n\", effect_size_advanced))\n      cat(sprintf(\"• 95%% Credible Interval (approx.): [%.4f, %.4f]\\n\", ci_95_advanced[1], ci_95_advanced[2]))\n  } else {\n      # Set to NA if parameters were not found\n      prob_hypothesis_advanced <- NA\n      effect_size_advanced <- NA\n      ci_95_advanced <- c(NA, NA)\n      cat(\"⚠️ WARNING: Expected parameters not found in model output.\\n\")\n  }\n \n  cat(\"\\n✅ ADVANCED PARAMETER EXTRACTION COMPLETE\\n\")\n \n} else {\n  cat(\"\\n❌ CANNOT EXTRACT PARAMETERS DUE TO MODEL FAILURE\\n\")\n  # Assign NA so the next chunk doesn't fail\n  prob_hypothesis_advanced <- NA \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n🔍 EXTRACTING PARAMETERS FROM ADVANCED MODEL...\n======================================================= \n🎯 PRELIMINARY RESULTS (ADVANCED MODEL):\n============================================= \n• P(asymmetry_cog > asymmetry_phys): 0.00%\n• Median Asymmetry Difference: -0.5865\n• 95% Credible Interval (approx.): [-0.6923, -0.4836]\n\n✅ ADVANCED PARAMETER EXTRACTION COMPLETE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# =============================================================================\n# BAYESIAN PREDICTIONS (ADVANCED MODEL)\n# =============================================================================\n\nif(exists(\"all_success_advanced\") && all_success_advanced) {\n  cat(\"\\n🔮 GENERATING BAYESIAN PREDICTIONS (ADVANCED MODEL)...\\n\")\n  cat(\"=\" %>% rep(60) %>% paste(collapse = \"\"), \"\\n\")\n \n  generate_advanced_bayesian_predictions <- function(model_cog, model_phys, n_points = 100) {\n   \n    status_range <- seq(-4, 4, length.out = n_points)\n    delta_up_range <- pmax(0, status_range)\n    delta_down_range <- pmax(0, -status_range)\n   \n    # Must include quadratic terms in prediction data\n    newdata_cog <- data.frame(\n      delta_up = delta_up_range,\n      delta_down = delta_down_range,\n      delta_up2 = delta_up_range^2,\n      delta_down2 = delta_down_range^2,\n      d_ij = median(cognitive_data_sample$d_ij, na.rm = TRUE)\n    )\n   \n    newdata_phys <- data.frame(\n      delta_up = delta_up_range,\n      delta_down = delta_down_range,\n      delta_up2 = delta_up_range^2,\n      delta_down2 = delta_down_range^2,\n      d_ij = median(physical_data_sample$d_ij, na.rm = TRUE)\n    )\n   \n    pred_cog <- fitted(model_cog, newdata = newdata_cog, summary = TRUE)\n    pred_phys <- fitted(model_phys, newdata = newdata_phys, summary = TRUE)\n   \n    predictions <- rbind(\n      data.frame(\n        status_gap = status_range,\n        probability = pred_cog[, \"Estimate\"],\n        lower_95 = pred_cog[, \"Q2.5\"],\n        upper_95 = pred_cog[, \"Q97.5\"],\n        content_type = \"Socio-cognitive\"\n      ),\n      data.frame(\n        status_gap = status_range,\n        probability = pred_phys[, \"Estimate\"],\n        lower_95 = pred_phys[, \"Q2.5\"],\n        upper_95 = pred_phys[, \"Q97.5\"],\n        content_type = \"Socio-technical\"\n      )\n    )\n   \n    return(predictions)\n  }\n \n  bayesian_advanced_predictions <- generate_advanced_bayesian_predictions(\n    results_cognitive_advanced$model, \n    results_physical_advanced$model\n  )\n \n  cat(\"✅ Advanced model predictions generated.\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n🔮 GENERATING BAYESIAN PREDICTIONS (ADVANCED MODEL)...\n============================================================ \n✅ Advanced model predictions generated.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# =============================================================================\n# BAYESIAN VISUALIZATION (ADVANCED MODEL)\n# =============================================================================\n\nif(exists(\"all_success_advanced\") && all_success_advanced && exists(\"bayesian_advanced_predictions\")) {\n \n  # Safely handle NA values so the plot doesn't fail\n  if (is.na(prob_hypothesis_advanced)) {\n    evidence_label_advanced <- \"INDETERMINATE\"\n    caption_text <- \"95% Credible Interval (HMC). Model results were indeterminate.\"\n  } else {\n    evidence_label_advanced <- if(prob_hypothesis_advanced > 0.99) \"STRONG\" \n                               else if(prob_hypothesis_advanced > 0.95) \"MODERATE\"\n                               else \"WEAK\"\n    caption_text <- sprintf(\"95%% Credible Interval (HMC). Evidence for linear asymmetry: **%s** (P = %.1f%%)\", \n                            evidence_label_advanced, prob_hypothesis_advanced * 100)\n  }\n  \n  equation_str_adv <- \"logit(P) = &theta;<sub>0</sub> - &lambda;d - &beta;<sub>1</sub><sup>+</sup>&Delta;<sup>+</sup> - &beta;<sub>2</sub><sup>+</sup>(&Delta;<sup>+</sup>)<sup>2</sup> - &beta;<sub>1</sub><sup>-</sup>&Delta;<sup>-</sup> - &beta;<sub>2</sub><sup>-</sup>(&Delta;<sup>-</sup>)<sup>2</sup>\"\n\n\n  p_bayesian_advanced <- ggplot(bayesian_advanced_predictions, \n                                aes(x = status_gap, color = content_type, fill = content_type)) +\n   \n    geom_ribbon(aes(ymin = lower_95, ymax = upper_95), alpha = 0.2, color = NA) +\n    geom_line(aes(y = probability), linewidth = 2, alpha = 0.9) +\n    geom_vline(xintercept = 0, linetype = \"dashed\", alpha = 0.8, color = \"gray40\", linewidth = 1) +\n    scale_color_manual(values = color_palette, name = \"Skill Type:\") +\n    scale_fill_manual(values = color_palette, name = \"Skill Type:\") +\n    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +\n    scale_x_continuous(breaks = seq(-4, 4, 2)) +\n   \n    labs(\n      title = \"Advanced Bayesian Analysis: Curvature Effects\",\n      subtitle = paste(\"Model:\", equation_str_adv),\n      x = \"Educational Status Gap (Destination - Source)\",\n      y = \"Predicted Skill Diffusion Probability\",\n      caption = caption_text\n    ) +\n   \n    theme_paper(base_size = 16) +\n    theme(\n      plot.title = element_text(size = rel(1.4)),\n      plot.subtitle = element_markdown(size = rel(1.2)),\n      plot.caption = element_markdown(size = rel(0.9)),\n      legend.position = \"bottom\"\n    )\n \n  print(p_bayesian_advanced)\n \n  ggsave(file.path(output_dir, \"bayesian_advanced_hmc_channeling.png\"), \n         p_bayesian_advanced, width = 12, height = 8, dpi = 300, bg = \"white\")\n \n  cat(\"\\n✅ ADVANCED VISUALIZATION COMPLETE\\n\")\n \n} else {\n  cat(\"\\n❌ COULD NOT GENERATE ADVANCED VISUALIZATION\\n\")\n  cat(\"Reason: Advanced Bayesian analysis did not complete successfully.\\n\")\n}\n```\n\n::: {.cell-output-display}\n![](01_model_files/figure-html/bayesian-visualization-advanced-1.png){width=3600}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n✅ ADVANCED VISUALIZATION COMPLETE\n```\n\n\n:::\n:::\n\n\n\n# Discussion: The Stratification Engine\n\nOur empirical results provide robust evidence that the process of **Asymmetric Trajectory Channeling** emerges from fundamentally different piecewise diffusion processes operating for cognitive and physical skills. The significant difference in the directional asymmetry parameters (β⁺ - β⁻) demonstrates that these skill types follow qualitatively distinct mobility regimes, with our piecewise specification eliminating previous concerns about multicollinearity.\n\n**Escalator Dynamics for Cognitive Skills**: The strong aspirational pattern (β⁺ = +0.4440, β⁻ = -0.2582), shows that cognitive skills are actively facilitated in upward movements while being penalized in downward ones. This confirms our hypothesis that cognitive skills are readily adopted by organizations seeking to establish higher-status occupations. The piecewise specification allows us to precisely quantify this: upward moves (Δ⁺) receive a substantial facilitation of +0.4440 while downward moves (Δ⁻) face a penalty of -0.2582.\n\n**Neutral Dynamics for Physical Skills**: The contrasting pattern for physical skills shows minimal directional bias (β⁺ = -0.1216, β⁻ = -0.2251), with both movements facing slight penalties but downward moves being more penalized. This indicates they diffuse based primarily on functional considerations rather than strong status signaling.\n\n**Methodological Advancement**: Our piecewise approach resolves the multicollinearity problem inherent in previous formulations that used both (s_j - s_i) and |s_j - s_i|. By defining Δ⁺ = max(0, s_j - s_i) and Δ⁻ = max(0, s_i - s_j), we create orthogonal variables (Δ⁺ · Δ⁻ = 0 always) that allow for unambiguous interpretation of directional effects. The use of non-linear models with shrinkage priors (Laplace) further allows for flexible detection of curvature while preventing overfitting.\n\n**Robust Statistical Evidence**: Both our frequentist piecewise models and Bayesian analyses provide consistent evidence for these patterns, with the asymmetry difference confirming the strong aspirational channeling effect for cognitive skills. This confirms stratification as an active, demand-side process driven by **organizational imitation patterns** where cognitive skills benefit from systematic upward facilitation while physical skills face more neutral or constrained mobility patterns.\n\n# Conclusions and Future Directions\n\nThis study makes several key contributions. Theoretically, we specify a **piecewise dual process model** of **inter-organizational imitation** that eliminates multicollinearity concerns while demonstrating that cognitive and physical skills follow fundamentally distinct diffusion logics. Our **Piecewise Dual Process Diffusion Model**, especially its non-linear extension with shrinkage priors, provides direct evidence for content-specific directional filtering mechanisms.\n\nEmpirically, our analysis provides robust evidence for distinct directional asymmetries and the resulting macro-level process of **Asymmetric Trajectory Channeling**. The piecewise specification allows for precise quantification of upward versus downward mobility penalties, offering clear policy targets. Methodologically, we demonstrate how piecewise regression approaches can resolve common econometric problems in diffusion studies while maintaining theoretical interpretability. This approach could be valuable for other scholars studying directional processes in organizational and economic contexts.\n\nFuture research should examine the temporal dynamics of these piecewise diffusion patterns, test our framework in different institutional contexts, and run the full MCMC version of the advanced model presented here to obtain more precise posterior distributions for the final publication.\n\n---\n\n**Data Availability Statement**: O*NET data is publicly available from the U.S. Department of Labor.\n",
    "supporting": [
      "01_model_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}