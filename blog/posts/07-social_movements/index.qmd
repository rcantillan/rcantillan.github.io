---
title: "Poder, Coaliciones y Vínculos Múltiples en la Movilización Urbana"
subtitle: "El Conflicto por el Plan Regulador de Peñalolén 2011"
author: 
  - name: "Roberto Cantillan"
    affiliations: 
        - name: "Department of Sociology, PUC"
          address: "Santiago, Chile"
date: 2024-11-13
website-url: "https://rcantillan.github.io/blog/posts/07-social_movements/"
#bibliography: references.bib
bibliographystyle: apa
categories:
  - R
  - Networks
  - ERGM
  - Social Movements
  - Contentious polítics 
image: "featured.jpg"
title-block-banner: featured.jpg
title-block-banner-color: "rgba(0,38,66,0.75)"
title-block-style: default
draft: false
---

# Introduction

Urban social movements represent complex networks of relationships between heterogeneous actors who coordinate collective action through multiple types of ties (Diani, 2015). The conflict over Peñalolén's Master Plan in 2011 provides an exemplary case to analyze how these multiplex networks facilitate the emergence and diffusion of contentious political identities, enabling broad coalition formation among diverse urban actors.

## Theoretical Framework

### Networks and Contentious Politics

Our analysis integrates two complementary theoretical perspectives: social movement networks and contentious politics. From a network perspective, movements emerge from dense webs of multiplex relationships that facilitate resource mobilization and sustain collective identities (Diani, 2003; Mische, 2003). These networks serve both instrumental and symbolic functions - channeling resources while also cultivating shared interpretive frames (Passy & Giugni, 2001).

The contentious politics approach emphasizes how political opportunities and threats trigger episodes of contention through mechanisms like boundary activation and polarization (McAdam et al., 2001; Tilly & Tarrow, 2015). These mechanisms operate through relational processes of brokerage and scale shift that connect previously disparate actors into broader coalitions (Tarrow, 2005).

### Multiplex Ties and Movement Integration 

Following Gould's (1991) seminal work, we conceptualize tie multiplexity not merely as a descriptive network feature but as a fundamental mechanism that:

1. Generates structural resistance to demobilization
2. Facilitates coordination between diverse actors  
3. Produces mutual reinforcement between different types of relationships

This multiplexity operates at both micro and macro levels. At the micro level, multiple ties between specific organizations reinforce commitments and reduce uncertainty in interactions (Baldassarri & Diani, 2007). At the macro level, multiplexity increases overall network robustness and enables the integration of different organizational clusters while sustaining broader collective identities (Diani, 2015).

### Boundary Mechanisms and Network Evolution

Drawing on Tilly (2004), we analyze how boundary change mechanisms shape movement dynamics through:

1. Inscription-Erasure: The creation/dissolution of social boundaries
2. Activation-Deactivation: Changes in the salience of existing boundaries
3. Site Transfer: Relocation of actors relative to boundaries
4. Relocation: Shifts in boundary-organizing relations

These mechanisms interact with network structures to shape patterns of diffusion and coalition formation (Tilly & Tarrow, 2015).

### Complex Diffusion in Movement Networks

Recent work on complex contagion demonstrates that the spread of contentious behaviors through networks depends on:

1. Multiple exposures through redundant ties (Centola & Macy, 2007)
2. Local clustering that provides social reinforcement (Centola, 2018) 
3. Strong ties that sustain costly forms of activism (McAdam & Paulsen, 1993)

This suggests that multiplex ties may be particularly important for the diffusion of contentious identities and practices.

## Hypotheses

Building on this theoretical framework, we propose four hypotheses:

H1: Structural Effects
- Network formation will exhibit significant transitivity (GWESP)
- Degree distributions will be relatively homogeneous (GWDegree)

H2: Conditional Homophily  
- Organizational type homophily will be stronger for trust/values ties than instrumental ties
- Structural block homophily will moderate organizational type homophily

H3: Strategic Multiplexity
- Multiple ties increase the probability of new tie formation
- This effect is stronger between organizations of different types/blocks

H4: Complex Diffusion
- Adoption of contentious positions requires multiple exposures
- Local clustering positively moderates adoption probability
- Triadic structures are more effective than dyadic ones

# Data and Methods

## Research Design

We employ a mixed-methods design (Domínguez & Hollstein, 2014) combining social network analysis with qualitative contextual data. Our approach conceptualizes relational structure as a multidimensional space of social positions in which population members are non-randomly distributed (Scott, 2011).

## Data Collection

Data was collected during 2017-2018 through:

1. Network Surveys (N=31)
   - Name generator limited to 5 nominations
   - Multiple tie types 
   - Organizational attributes

2. In-depth Interviews (N=12)
   - Key informants
   - Conflict history
   - Coordination dynamics

3. Documentary Sources
   - Local press coverage
   - Organizational documents
   - Meeting minutes

The sampling strategy combined:

- Initial identification of organization types
- Snowball sampling until saturation (40% name repetition)
- Secondary source validation

## Networks and Attributes

We analyze five types of ties between 70 organizations:

1. Cooperation (joint activities)
2. Trust (historical bonds)
3. Resources (material support)
4. Values (interpretive frames) 
5. Kinship (family ties)

## Limitations

Important methodological limitations include:

1. Temporal bias from retrospective data collection
2. Potential underrepresentation of peripheral actors
3. Artificial cap on nominations (5)
4. Difficulty capturing tie intensity

## Estrategia Analítica

1. **Análisis Descriptivo:**
   - Medidas de centralidad
   - Detección de bloques
   - Análisis de multiplexidad

2. **Modelación ERGM:**
   - Efectos estructurales
   - Homofilia condicional 
   - Interacción entre vínculos

3. **Modelo de Difusión:**
   - Contagio complejo
   - Umbrales heterogéneos
   - Efectos de estructura local

# Resultados

```{r setup}
#| message: false
library(tidyverse)
library(igraph)
library(tidygraph)
library(statnet)
library(ergm)
library(ggplot2)
library(network)
library(kableExtra)
library(plotly)
library(gridExtra)
library(viridis)
library(sna)
library(concorR)
library(ggraph)
library(Matrix)
library(patchwork)
library(texreg)
```


## Descriptivos
### Red
```{r datos}
#| message: false
#| warning: false


# Leer y preparar las matrices
coop_matrix <-       as.matrix(read.csv("datos/CoopNet.csv", header=FALSE))
trust_matrix <-      as.matrix(read.csv("datos/ConfianzaNet.csv", header=FALSE))
resources_matrix <-  as.matrix(read.csv("datos/RecursosNet.csv", header=FALSE))
values_matrix <-     as.matrix(read.csv("datos/ValoresNet.csv", header=FALSE))
parentesco_matrix <- as.matrix(read.csv("datos/ParentescoNet.csv", header=FALSE))

# Leer atributos
attributes <- read.csv("datos/Atributos _org2011.csv", header=TRUE)

# Verificar si las redes son dirigidas
is_directed <- list(
  Cooperacion = !isSymmetric(coop_matrix),
  Confianza = !isSymmetric(trust_matrix),
  Recursos = !isSymmetric(resources_matrix),
  Valores = !isSymmetric(values_matrix),
  Parentesco = !isSymmetric(parentesco_matrix)
)

print("Verificación de direccionalidad de las redes:")
print(unlist(is_directed))

# Lista de todas las matrices para análisis
matrices_list <- list(
  Cooperacion = coop_matrix,
  Confianza = trust_matrix,
  Recursos = resources_matrix,
  Valores = values_matrix,
  Parentesco = parentesco_matrix
)

map_lgl(matrices_list, is.matrix)
map_lgl(matrices_list, function(x) nrow(x) == ncol(x))


print("\nEstadísticas descriptivas de las redes:")
map_dfr(matrices_list, function(x) {
  g <- graph_from_adjacency_matrix(x, mode="directed")
  tibble(
    Densidad = edge_density(g),
    N_lazos = sum(x),
    N_nodos_activos = sum(rowSums(x) > 0),
    Reciprocidad = reciprocity(g),
    Transitivity = transitivity(g),
    Componentes = count_components(g),
    Diametro = diameter(g, directed=TRUE, weights=NA)
  )
}, .id = "Red") %>% 
  kbl() %>%
  kable_paper("hover", full_width = T)
```


#### Network Structure and Organizational Field

Our analysis of network structure reveals a clear organizational field configuration characterized by differential density patterns across network types. These patterns suggest a hierarchical integration of the field, where:

#### Political Organizations Dominance:

- MPL (Movimiento de Pobladores en Lucha) shows highest indegree (13)
- OCAP (Organización política de base) follows with high centrality (7)
- Housing committees (CV_BrillaElSol) maintain significant positions (6)

[Quote opportunity: MPL leader discussing their role in coordinating different organizations]


### Actores 
```{r actores}
#| message: false
#| warning: false


# Crear objeto network con atributos
net_coop <- network(coop_matrix, directed=TRUE)

# Agregar atributos a la red
net_coop %v% "tipo" <- attributes$Tipo_de_organización
net_coop %v% "ubicacion" <- attributes$Ubicación
net_coop %v% "orientacion" <- attributes$Orientación

# Calcular medidas de centralidad
cent_df <- data.frame(
  Organizacion = attributes$Nombre,
  Tipo = attributes$Tipo_de_organización,
  Orientacion = attributes$Orientación,
  # Centralidades
  Degree = sna::degree(net_coop, gmode="digraph"),
  Indegree = sna::degree(net_coop, gmode="digraph", cmode="indegree"),
  Outdegree = sna::degree(net_coop, gmode="digraph", cmode="outdegree"),
  Betweenness = sna::betweenness(net_coop),
  Eigenvector = sna::evcent(net_coop)
)

# Top 10 actores más centrales según diferentes medidas
print("Top 10 actores según Indegree:")

cent_df %>%
  arrange(desc(Indegree)) %>%
  select(Organizacion, Tipo, Indegree) %>%
  head(10) %>%
  kbl() %>%
  kable_paper("hover", full_width = T)

print("\nTop 10 actores según Betweenness:")
cent_df %>%
  arrange(desc(Betweenness)) %>%
  select(Organizacion, Tipo, Betweenness) %>%
  head(10) %>%
  kbl() %>%
  kable_paper("hover", full_width = T)

# Análisis de centralidad por tipo de organización
cent_by_type <- cent_df %>%
  group_by(Tipo) %>%
  summarise(
    Mean_Indegree = mean(Indegree),
    Mean_Betweenness = mean(Betweenness),
    N = n()
  )

print("\nCentralidad promedio por tipo de organización:")
cent_by_type %>%
  kbl() %>%
  kable_paper("hover", full_width = T)
```


#### Structural Differentiation: Core political organizations average higher betweenness centrality (119.85 for political base organizations, 126.24 for pobladores organizations) compared to neighborhood organizations (22.11).



### Equivalencia estructural

The CONCOR analysis identified four distinct blocks:

#### Political-Strategic Block (18 organizations):

- 9 Housing Committees
- 4 Cultural Organizations
- 4 Sports Clubs
- 1 Municipal Actor

#### Cultural-Tactical Block (13 organizations):

- 8 Cultural Organizations
- 1 Political Base Organization
- 4 Others

#### Base Organization Block (14 organizations):

- 6 Pobladores Organizations
- 5 Base Political Organizations
- 3 Neighborhood Organizations

#### Neighborhood Block (15 organizations):

- Exclusively neighborhood organizations


[Quote opportunity: Description of different organizational roles in the movement]

```{r bloques}
#| message: false
#| warning: false


# Leer datos
coop_matrix <- as.matrix(read.csv("datos/CoopNet.csv", header=FALSE))
attributes <- read.csv("datos/Atributos _org2011.csv", header=TRUE)

# Realizar CONCOR
bloques <- concor(list(coop_matrix), cutoff=0.8, nsplit=2)

# Ver composición de los bloques
for(i in 1:4) {
    cat(paste("\n\nBLOQUE", i, "\n"))
    cat("---------------\n")
    organizaciones <- attributes[bloques == i, ]
    print(table(organizaciones$Tipo))
    cat("\nOrganizaciones específicas:\n")
    print(organizaciones$Nombre)
}

# Calcular densidades entre bloques
block_density <- matrix(0, 4, 4)
for(i in 1:4) {
    for(j in 1:4) {
        nodes_i <- which(bloques == i)
        nodes_j <- which(bloques == j)
        if(length(nodes_i) > 0 && length(nodes_j) > 0) {
            block_density[i,j] <- sum(coop_matrix[nodes_i, nodes_j]) / 
                                 (length(nodes_i) * length(nodes_j))
        }
    }
}

# Mostrar densidades
cat("\n\nDensidad entre bloques:\n")
print(round(block_density, 3))

# Calcular cohesión de bloques
for(i in 1:4) {
    cat(paste("\n\nCohesión Bloque", i, "\n"))
    internal <- block_density[i,i]
    external <- mean(block_density[i,-i])
    ei_index <- (external - internal)/(external + internal)
    cat(paste("Densidad interna:", round(internal, 3), "\n"))
    cat(paste("Densidad externa media:", round(external, 3), "\n"))
    cat(paste("Índice E-I:", round(ei_index, 3), "\n"))
}
```



```{r bloques2}
#| message: false
#| warning: false


# 1. Preparar datos para el heatmap de densidades entre bloques
density_df <- expand.grid(
  from = factor(1:4, labels = paste("Bloque", 1:4)),
  to = factor(1:4, labels = paste("Bloque", 1:4))
) %>%
  mutate(density = as.vector(block_density))



# 2. Preparar datos para la composición de bloques
composicion_bloques <- data.frame(
  Bloque = rep(1:4, c(18, 13, 14, 15)),
  Tipo = c(
    rep(c("Comite Vivienda","Org. Cultural","Club Deportivo","Gob. Municipal"), c(9,4,4,1)), # Bloque 1
    rep(c("Org. Política Base","Org. Cultural","Otros"), c(1,8,4)), # Bloque 2
    rep(c("Org. Vecinal","Org. Política Pobladores","Org. Política Base"), c(3,6,5)), # Bloque 3
    rep("Org. vecinal", 15) # Bloque 4
  )
)

# 3. Preparar datos para métricas de cohesión
cohesion_df <- data.frame(
  Bloque = factor(1:4, labels = paste("Bloque", 1:4)),
  Densidad_interna = diag(block_density),
  Densidad_externa = sapply(1:4, function(i) mean(block_density[i,-i])),
  EI_index = sapply(1:4, function(i) {
    internal <- block_density[i,i]
    external <- mean(block_density[i,-i])
    (external - internal)/(external + internal)
  })
) %>%
  pivot_longer(cols = -Bloque, 
               names_to = "Metrica", 
               values_to = "Valor")

# Crear las visualizaciones

# 1. Heatmap de densidades
p1 <- ggplot(density_df, aes(x = from, y = to, fill = density)) +
  geom_tile() +
  scale_fill_viridis() +
  labs(title = "Densidad entre Bloques",
       x = "Bloque Origen",
       y = "Bloque Destino",
       fill = "Densidad") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# 2. Composición de bloques
p2 <- ggplot(composicion_bloques, aes(x = factor(Bloque), fill = Tipo)) +
  geom_bar(position = "fill") +
  scale_fill_viridis_d() +
  labs(title = "Composición de Bloques",
       x = "Bloque",
       y = "Proporción",
       fill = "Tipo de Organización") +
  theme_minimal()

# 3. Métricas de cohesión
p3 <- ggplot(cohesion_df, aes(x = Bloque, y = Valor, fill = Metrica)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis_d() +
  labs(title = "Métricas de Cohesión por Bloque",
       x = "Bloque",
       y = "Valor",
       fill = "Métrica") +
  theme_minimal()

# Convertir a plotly
p1_plotly <- ggplotly(p1)
p2_plotly <- ggplotly(p2)
p3_plotly <- ggplotly(p3)

# Mostrar los plots
p1_plotly
p2_plotly
p3_plotly
```


```{r}
# Create multiplex network
multiplex_matrix <- coop_matrix * 0.3 + 
                   trust_matrix * 0.3 + 
                   resources_matrix * 0.2 + 
                   values_matrix * 0.2

# Create graph
g <- graph_from_adjacency_matrix(multiplex_matrix, mode="directed", weighted=TRUE)

# Add vertex attributes using existing data
V(g)$degree <- igraph::degree(g)
V(g)$betweenness <- igraph::betweenness(g)
V(g)$eigenvector <- eigen_centrality(g)$vector
V(g)$block <- attributes$X1PosciónCONCOR
V(g)$type <- attributes$Tipo_de_organización
V(g)$orientation <- attributes$Orientación
V(g)$nombre <- attributes$Nombre


# Add edge attributes
edge_list <- as_edgelist(g)
E(g)$block_tie <- ifelse(
  V(g)$block[edge_list[,1]] == V(g)$block[edge_list[,2]], 
  paste0("Block", V(g)$block[edge_list[,1]]), 
  "between"
)

# Network plot with ggraph
p1 <- ggraph(g, layout = "fr") +
  geom_edge_link(aes(alpha = ifelse(V(g)$block[from] == V(g)$block[to], 0.6, 0.2)),
                 color = "black",
                 arrow = arrow(length = unit(2, 'mm'))) +
  geom_node_point(aes(size = betweenness,
                     color = as.factor(block)),
                 alpha = 0.7) +
  geom_node_label(aes(label = ifelse(betweenness > quantile(betweenness, 0.92),
                                    nombre, "")),
                 repel = TRUE,
                 size = 3) +
  scale_color_viridis_d(option = "D",
                       name = "Bloque",
                       labels = c("Político", "JJ.VV", "Base", "Cultural")) +
  scale_size_continuous(name = "Intermediación",
                       range = c(2, 8),
                       breaks = c(0, 0.025, 0.05, 0.075, 0.1, 0.125),
                       labels = c("0.000", "0.025", "0.050", "0.075", "0.100", "0.125")) +
  guides(color = guide_legend(override.aes = list(size = 5)),
         size = guide_legend(override.aes = list(alpha = 1)),
         edge_alpha = guide_legend(title = "Vinculo")) +  # Eliminamos el título de la leyenda edge_alpha
  labs(title = "") +
  theme_graph() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5, size = 14),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 12)) 

print(p1)

```



This suggests:

- Integration occurs through nested hierarchies
- Cultural organizations serve as brokers
- Political organizations maintain core-periphery structure

This extends Diani's (2015) movement integration theory by specifying:

- The role of organizational heterogeneity
- The importance of cultural brokers
- The hierarchical nature of integration

## ERGM
```{r ergm}
#| echo: true 
#| message: false
#| warning: false


# Verificar distribución de grados
out_degrees <- sna::degree(net_coop)
table(out_degrees)
max(out_degrees)

# Agregar constraints para manejar el límite de nominaciones
model2 <- ergm(net_coop ~ 
               edges + 
               gwesp(0.25, fixed = TRUE) + 
               gwidegree(0.25, fixed=TRUE) + 
               #gwdegree(0.25, fixed = TRUE) +
               edgecov(trust_matrix) + 
               edgecov(resources_matrix) +
               edgecov(parentesco_matrix) +
               #nodefactor("tipo") +
               #nodefactor("orientacion") +
               #nodefactor("ubicacion") +
               nodematch("tipo") + 
               nodematch("orientacion", diff=TRUE) +
               nodematch("ubicacion"),
               constraints = ~bd(maxout=max(out_degrees)), 
               control = control.ergm(seed = 123,
                                    MCMLE.maxit = 25, # Aumentar iteraciones 
                                    MCMC.burnin = 5000, # Aumentar burn-in
                                    MCMC.interval = 100, # Aumentar intervalo
                                    MCMC.samplesize = 5000, # Aumentar tamaño de muestra
                                    parallel = 2,
                                    parallel.type = "PSOCK"))

```


```{r, results='asis'}
# Print summary
htmlreg(model2,
        stars=c(0.01,0.05,0.1), 
        digits=3, 
        star.symbol='&#42;',
        custom.note = paste("%stars."),
         align.center=TRUE,
        single.row = T, 
        bold = 0.05)
```

**Trust-Based Diffusion**: The strongest positive effect (6.423***) comes from trust networks, supporting Passy & Monsch's (2014) argument that identity transformation occurs primarily through trust relationships. Your case shows how historical relationships between pobladores organizations provided the foundation for contentious identity spread.

[Quote opportunity: Leader discussing how long-term trust relationships facilitated political alignment]

**Resource Network Amplification**: The strong positive effect of resource ties (5.513) indicates that material interdependencies reinforced identity diffusion, consistent with Diani's (2015) findings about movement infrastructure. In Peñalolén, resource sharing created durable channels for identity transmission.

**Kinship Network Constraint**: The negative effect of kinship ties (-3.082) suggests these relationships actually inhibited contention diffusion, contrasting with some social movement literature but aligning with Gould's (1991) findings about the primacy of political over personal ties in contentious episodes.

**Triadic Closure**: Significant GWESP effect (1.899) indicates importance of local clustering in network formation. The significant GWESP effect combined with trust-resource complementarity suggests a new theoretical mechanism: "networked capacity building", where:

- Local clustering provides social validation
- Multiple ties build organizational capacity
- Different tie types serve distinct but complementary functions



```{r}
#| message: false

# Assess goodness-of-fit  
gof <- gof(model2)
print(gof)
plot(gof)
```


```{r}
#| message: false
#| 
# Plot diagnostics  
mcmc.diagnostics(model2)
```



## Difusión
### Función para proceso de difusión 

La función `improved_diffusion_v9` implementa un modelo de difusión de comportamientos conflictivos basado en la teoría de movimientos sociales y contienda política. El modelo integra conceptos clave de:

- **Teoría de Redes en Movimientos Sociales** (Diani): Multiplicidad de vínculos, roles estructurales
- **Dinámica de la Contienda** (McAdam, Tilly, Tarrow): Mecanismos relacionales, repertorios de acción
- **Costos de Acción Colectiva** (Olson): Incentivos selectivos, problemas de coordinación
- **Identidad Colectiva** (Melucci): Alineamiento identitario, solidaridad

#### Componentes Estructurales

#####  Umbrales Heterogéneos
```{r}
#| eval: false 
  
thresholds <- list(
    base = 0.05,
    by_type = c(
      " Club deportivo " = 0.15,
      " Comité de vivienda " = 0.06,
      " Organización política de pobladores " = 0.05))
```

La heterogeneidad en umbrales refleja la teoría de Tarrow sobre "madrugadores" (early risers) en ciclos de protesta:

- **Organizaciones de pobladores** (0.05): Menor umbral por su tradición histórica de movilización
- **Comités de vivienda** (0.06): Umbral bajo por demandas materiales concretas
- **Organizaciones culturales/deportivas** (0.15): Mayor umbral por orientación no confrontacional

#### Multiplicidad de Vínculos
```{r}
#| eval: false

weights <- c(0.35, 0.35, 0.15, 0.15) # Confianza, valores, parentesco, recursos
```

Siguiendo a Diani, se pondera diferencialmente distintos tipos de vínculos:

- **Vínculos fuertes** (confianza/valores): Mayor peso (0.35) por su rol en motivar participación riesgosa
- **Vínculos instrumentales** (recursos): Menor peso (0.15) por su naturaleza transaccional
- **Vínculos primordiales** (parentesco): Peso reducido (0.15) por ser menos relevantes para acción colectiva

#### Mecanismos Relacionales

##### Clustering Local
```{r}
#| eval: false

calc_local_clustering <- function(node, networks) {
    cluster_scores <- sapply(networks, function(x) {
      neighbors <- which(x[node,] > 0)
      submat <- x[neighbors, neighbors]
      sum(submat) / (length(neighbors) * (length(neighbors)-1))
    })
}
```

Operacionaliza el concepto de "estructuras de movilización" (McAdam):

- Mide cohesión en entorno inmediato
- Mayor clustering facilita coordinación
- Reduce costos de acción colectiva

#### Exposición Temporal
```{r}
#| eval: false

calc_exposure_time <- function(node, history, window = memory_window) {
    weights <- exp(-(current_window:1)/3)
    return(weighted.mean(exposed_neighbors, weights))
}
```

Implementa "memoria colectiva" en movilización:

- Exposición acumulada reduce percepción de riesgo
- Decay exponencial modela olvido social
- Ventana móvil captura ciclos de protesta

#### Alineamiento Identitario
```{r}
#| eval: false

identity_alignment <- function(node, attributes) {
    same_type <- attributes$tipo == attributes$tipo[node]
    same_orientation <- attributes$Orientación == attributes$Orientación[node]
    return(mean(same_type & same_orientation))
}
```

Basado en teoría de identidad colectiva:

- Similitud organizacional fortalece solidaridad
- Orientación política común facilita difusión
- Alineamiento reduce barreras a adopción

#### Roles Estructurales

```{r}
#| eval: false

role_scores$broker_score <- role_scores$between_score + role_scores$degree_score
role_scores$core_score <- role_scores$eigen_score + role_scores$authority_score
```

Operacionaliza roles clave en difusión (Tarrow):

- **Brokers**: Conectan comunidades distintas
- **Core**: Liderazgo y legitimidad en red
- **Authority**: Influencia sobre adopción
- **Peripheral**: Seguidores potenciales

#### Proceso de Difusión

##### Cálculo de Influencia
```{r}
#| eval: false

combined_influence <- net_influence * weights[n] * 
    temporal_factor * cluster_multiplier * 
    (1 + identity_effect) / action_cost
```

Integra múltiples mecanismos:

1. **Influencia base**: Proporción de vecinos adoptantes
2. **Factor temporal**: Exposición acumulada
3. **Multiplicador estructural**: Efecto de clustering
4. **Efecto identitario**: Alineamiento organizacional
5. **Costo de acción**: Fricción estructural

##### Umbrales Dinámicos
```{r}
#| eval: false

final_threshold <- (base_threshold * type_threshold) * 
    exp(-0.05 * exposure_effect) *
    (1 - 0.2 * cluster_effect)
```

Modela adaptación de umbrales por:

- Tipo organizacional (heterogeneidad)
- Exposición temporal (aprendizaje)
- Clustering local (solidaridad)

#### Métricas de Evaluación

El modelo produce métricas que permiten evaluar:

1. **Patrones de Difusión**
   - Tasa global de adopción
   - Variación por tipo organizacional
   - Trayectorias temporales

2. **Efectos Estructurales**
   - Impacto de clustering
   - Rol de brokers
   - Influencia de core

3. **Mecanismos Relacionales**
   - Exposición acumulada
   - Alineamiento identitario
   - Costos de acción

#### En síntesis

El modelo implementa computacionalmente teorías centrales de movimientos sociales:

1. **Dinámica relacional** (McAdam, Tilly, Tarrow)
   - Mecanismos de difusión
   - Roles estructurales
   - Ciclos de protesta

2. **Identidad y solidaridad** (Melucci, Diani)
   - Alineamiento organizacional
   - Vínculos múltiples
   - Cohesión local

3. **Acción colectiva** (Olson)
   - Costos diferenciados
   - Incentivos estructurales
   - Problemas de coordinación

La implementación permite estudiar empíricamente:

- Patrones de difusión de repertorios
- Roles estructurales en movilización
- Mecanismos relacionales de protesta


### Cargamos datos 
```{r}
# 1. Cargar datos
coop_matrix      <- as.matrix(read.csv("datos/CoopNet.csv", header=FALSE))
trust_matrix     <- as.matrix(read.csv("datos/ConfianzaNet.csv", header=FALSE))
resources_matrix <- as.matrix(read.csv("datos/RecursosNet.csv", header=FALSE))
values_matrix    <- as.matrix(read.csv("datos/ValoresNet.csv", header=FALSE))

# 2. Cargar atributos (cambiamos el nombre de la variable)
org_attributes <- read.csv("datos/Atributos _org2011.csv", header=TRUE) %>%
  mutate(
    conflictivo = trimws(Orientación) == "Conflictiva",  # Crear variable conflictivo
    tipo = Tipo_de_organización,
    ubicacion = Ubicación,
    orientacion = Orientación
  )


# 3. Verificar la creación correcta de la variable
print("Verificar variable conflictivo:")
table(org_attributes$conflictivo, org_attributes$Orientación, useNA = "always")

# 4. Preparar lista de redes
networks <- list(
  trust_matrix,    # Red de confianza (peso 0.3)
  values_matrix,   # Red de valores (peso 0.3)
  coop_matrix,     # Red de cooperación (peso 0.2)
  resources_matrix # Red de recursos (peso 0.2)
)
```



```{r}
#| code-fold: show

org_attributes$block <- as.factor(org_attributes$`X1PosciónCONCOR`)

improved_diffusion_v9 <- function(networks, attributes, seeds, 
                                  max_iterations = 1000,
                                  convergence_threshold = 0.001,
                                  memory_window = 5,
                                  use_heterogeneous_thresholds = TRUE) {
  
  # 1. Umbrales realistas para comportamiento conflictivo
  thresholds <- list(
    base = 0.05, # Umbral base alto para comportamiento conflictivo
    by_type = c(
      " Club deportivo " = 0.15,
      " Comité de vivienda " = 0.06,
      " Organización cultural " = 0.10,
      " Organización política de base " = 0.07,
      " Organización política de pobladores " = 0.05,
      " Organización vecinal " = 0.10,
      "Otros" = 0.15
    ))
  
  # 2. Validación de entrada y preprocesamiento
  networks <- lapply(networks, function(x) {
    if(!is.matrix(x)) stop("Todas las redes deben ser matrices")
    return(as.matrix(x))
  })
  
  if(!all(sapply(networks, function(x) all(dim(x) == dim(networks[[1]])))))
    stop("Todas las redes deben tener las mismas dimensiones")
  
  # 3. Inicialización
  n_nodes <- nrow(networks[[1]])
  weights <- c(0.35, 0.35, 0.15, 0.15) # Más peso a confianza y valores
  
  # 4. Crear red compuesta
  composite_net <- Reduce("+", Map("*", networks, weights))
  
  # 5. Calcular medidas estructurales
  g <- igraph::graph_from_adjacency_matrix(composite_net, 
                                           weighted = TRUE, 
                                           mode = "directed")
  
  # 6. Medidas de centralidad
  centrality_measures <- list(
    between = igraph::betweenness(g, normalized = TRUE),
    degree = igraph::degree(g, mode = "all", normalized = TRUE),
    eigen = igraph::eigen_centrality(g)$vector,
    authority = igraph::authority_score(g)$vector
  )
  
  # 7. Identificación de roles estructurales
  role_scores <- data.frame(
    node = 1:n_nodes,
    between_score = scale(centrality_measures$between),
    degree_score = scale(centrality_measures$degree),
    eigen_score = scale(centrality_measures$eigen),
    authority_score = scale(centrality_measures$authority)
  )
  
  # Calcular scores compuestos
  role_scores$broker_score <- role_scores$between_score + role_scores$degree_score
  role_scores$core_score <- role_scores$eigen_score + role_scores$authority_score
  
  # Asignar roles con umbrales más estrictos
  role_scores$role <- with(role_scores, {
    ifelse(broker_score > quantile(broker_score, 0.85), "broker",
           ifelse(core_score > quantile(core_score, 0.85), "core",
                  ifelse(authority_score > quantile(authority_score, 0.85), "authority",
                         "peripheral")))
  })
  
  # 8. Funciones auxiliares mejoradas
  calc_local_clustering <- function(node, networks) {
    cluster_scores <- sapply(networks, function(x) {
      neighbors <- which(x[node,] > 0)
      if(length(neighbors) < 2) return(0)
      submat <- x[neighbors, neighbors]
      sum(submat) / (length(neighbors) * (length(neighbors)-1))
    })
    weighted.mean(cluster_scores, weights)
  }
  
  calc_exposure_time <- function(node, history, window = memory_window) {
    # Si no hay historia, retornar 0
    if(is.null(history) || is.null(dim(history)) || nrow(history) == 0) return(0)
    
    # Si no hay vecinos, retornar 0
    if(length(node_neighbors[[node]]) == 0) return(0)
    
    # Ajustar ventana si es necesario
    current_window <- min(window, nrow(history))
    
    # Obtener historia reciente
    if(current_window == 1) {
      recent_history <- matrix(history, nrow=1)
    } else {
      recent_history <- tail(history, current_window)
    }
    
    # Calcular exposición de vecinos
    exposed_neighbors <- rowSums(recent_history[, node_neighbors[[node]], drop=FALSE])
    
    # Calcular pesos
    weights <- exp(-(current_window:1)/3)
    
    # Retornar media ponderada
    return(weighted.mean(exposed_neighbors, weights))
  }
  
  identity_alignment <- function(node, attributes) {
    # Mide similitud en atributos organizacionales
    same_type <- attributes$tipo == attributes$tipo[node]
    same_orientation <- attributes$Orientación == attributes$Orientación[node]
    return(mean(same_type & same_orientation))
  }
  
  collective_action_cost <- function(node, role_scores) {
    # Costo base por visibilidad estructural
    base_cost <- 1 + abs(role_scores$degree_score[node])
    
    # Modificador por rol
    role_modifier <- switch(role_scores$role[node],
                            "broker" = 1.3,
                            "core" = 1.2,
                            "authority" = 1.1,
                            1.0)
    
    return(base_cost * role_modifier)
  }
  
  # 9. Inicialización de estados y memorias
  states <- rep(0, n_nodes)
  states[seeds] <- 1
  
  # Crear lista de vecinos
  node_neighbors <- lapply(1:n_nodes, function(i) {
    unique(unlist(lapply(networks, function(x) which(x[i,] > 0))))
  })
  
  # 10. Inicialización de matrices de historia
  history <- matrix(0, nrow = max_iterations, ncol = n_nodes)
  history[1,] <- states
  exposure_memory <- matrix(0, nrow = max_iterations, ncol = n_nodes)
  exposure_memory[1,] <- sapply(1:n_nodes, function(i) {
    if(length(node_neighbors[[i]]) > 0) {
      mean(states[node_neighbors[[i]]])
    } else {
      0
    }
  })
  clustering_memory <- matrix(0, nrow = max_iterations, ncol = n_nodes)
  clustering_memory[1,] <- sapply(1:n_nodes, function(i) calc_local_clustering(i, networks))
  
  # 11. Proceso de difusión mejorado
  for(iter in 2:max_iterations) {
    old_states <- states
    
    # Procesar nodos inactivos
    inactive_nodes <- which(states == 0)
    
    for(i in inactive_nodes) {
      # Calcular influencia base
      influence <- 0
      total_weight <- 0
      
      # Influencia por tipo de red
      for(n in seq_along(networks)) {
        neighbors <- which(networks[[n]][i,] > 0)
        if(length(neighbors) > 0) {
          # Influencia ponderada por tipo de vínculo y tiempo
          net_influence <- sum(states[neighbors]) / length(neighbors)
          
          # Factor temporal de exposición
          exposure_time <- calc_exposure_time(i, history[1:(iter-1), , drop=FALSE])
          
          temporal_factor <- 1 - exp(-0.05 * exposure_time)
          
          # Efecto de clustering local
          cluster_effect <- calc_local_clustering(i, networks)
          cluster_multiplier <- 1 + (cluster_effect * 2)
          
          # Efecto de identidad
          identity_effect <- identity_alignment(i, attributes)
          
          # Costo de acción colectiva
          action_cost <- collective_action_cost(i, role_scores)
          
          # Combinar efectos
          combined_influence <- net_influence * weights[n] * 
            temporal_factor * cluster_multiplier * 
            (1 + identity_effect) / action_cost
          
          influence <- influence + combined_influence
          total_weight <- total_weight + weights[n]
        }
      }
      
      if(total_weight > 0) {
        # Normalizar influencia
        influence <- influence / total_weight
        
        if(use_heterogeneous_thresholds) {
          # Threshold dinámico con heterogeneidad
          base_threshold <- thresholds$base
          type_threshold <- thresholds$by_type[attributes$tipo[i]]
        } else {
          # Threshold dinámico sin heterogeneidad
          base_threshold <- thresholds$base
          type_threshold <- 1
        }
        
        # Ajustar threshold por exposición temporal y clustering
        exposure_effect <- mean(exposure_memory[1:max(1,iter-1), i], na.rm=TRUE)
        cluster_effect <- mean(clustering_memory[1:max(1,iter-1), i], na.rm=TRUE)
        
        final_threshold <- (base_threshold * type_threshold) * 
          exp(-0.05 * exposure_effect) *
          (1 - 0.2 * cluster_effect)
        
        # Probabilidad de adopción
        if(influence >= final_threshold) {
          # Fricción en adopción
          adoption_prob <- 0.3 * (1 + exposure_effect)
          states[i] <- rbinom(1, 1, min(1, adoption_prob))
        }
      }
      
      # Actualizar memorias
      exposure_memory[iter, i] <- ifelse(length(node_neighbors[[i]]) > 0,
                                         sum(states[node_neighbors[[i]]]) / length(node_neighbors[[i]]),
                                         0)
      clustering_memory[iter, i] <- calc_local_clustering(i, networks)
    }
    
    # Guardar historia
    history[iter,] <- states
    
    # Verificar convergencia
    if(iter > 20) {
      recent_window <- (iter-19):iter
      change_rate <- mean(diff(colMeans(history[recent_window,])))
      if(abs(change_rate) < convergence_threshold) break
    }
    
    if(all(old_states == states) && iter > 10) break
  }
  
  # 12. Calcular métricas finales
  final_metrics <- list(
    adoption_rate = mean(states),
    clustering_effect = sapply(1:n_nodes, function(i) calc_local_clustering(i, networks)),
    temporal_exposure = colMeans(exposure_memory[1:iter,], na.rm=TRUE),
    convergence_iteration = iter,
    change_trajectory = rowMeans(history[1:iter,]),
    adoption_by_type = tapply(states, attributes$tipo, mean),
    adoption_by_role = tapply(states, role_scores$role, mean),
    final_thresholds = sapply(1:n_nodes, function(i) {
      base_threshold <- if(use_heterogeneous_thresholds) {
        thresholds$by_type[attributes$tipo[i]]
      } else {
        thresholds$base
      }
      exposure_effect <- mean(exposure_memory[1:iter, i], na.rm=TRUE)
      cluster_effect <- mean(clustering_memory[1:iter, i], na.rm=TRUE)
      base_threshold * exp(-0.05 * exposure_effect) *
        (1 - 0.2 * cluster_effect)
    }),
    network_effects = list(
      clustering = mean(sapply(1:n_nodes, function(i) calc_local_clustering(i, networks))),
      exposure = mean(colMeans(exposure_memory[1:iter,], na.rm=TRUE)),
      identity = mean(sapply(1:n_nodes, function(i) identity_alignment(i, attributes))),
      costs = mean(sapply(1:n_nodes, function(i) collective_action_cost(i, role_scores)))
    )
  )
  
  # 13. Retornar resultados
  return(list(
    final_states = states,
    history = history[1:iter,],
    n_iterations = iter,
    role_scores = role_scores,
    centrality_measures = centrality_measures,
    composite_net = composite_net,
    exposure_memory = exposure_memory[1:iter,],
    clustering_memory = clustering_memory[1:iter,],
    final_metrics = final_metrics,
    converged = iter < max_iterations,
    parameters = list(
      thresholds = thresholds,
      weights = weights,
      memory_window = memory_window,
      convergence_threshold = convergence_threshold,
      use_heterogeneous_thresholds = use_heterogeneous_thresholds
    )
  ))
}
```


### Función para plotear 
```{r}
#| code-fold: show

plot_diffusion_results_v2 <- function(results, org_attributes) {
  library(ggplot2)
  library(dplyr)
  library(tidyr)
  library(patchwork)
  library(viridis)
  
  # 1. Datos para difusión total
  df_total <- data.frame(
    iteration = 1:nrow(results$history),
    proportion = rowMeans(results$history),
    exposure = rowMeans(results$exposure_memory)  # Cambio aquí: rowMeans en lugar de colMeans
  )
  
  # 2. Datos por tipo de organización
  df_by_type <- data.frame(results$history) %>%
    mutate(iteration = row_number()) %>%
    pivot_longer(-iteration, names_to = "node", values_to = "state") %>%
    mutate(node = as.numeric(gsub("[^0-9]", "", node))) %>%
    left_join(
      data.frame(
        node = 1:nrow(org_attributes),
        tipo = org_attributes$Tipo_de_organización
      ),
      by = "node"
    ) %>%
    group_by(iteration, tipo) %>%
    summarise(
      proportion = mean(state),
      n_adopted = sum(state),
      n_total = n(),
      .groups = 'drop'
    )
  
  # 3. Análisis de roles y adopción
  role_adoption <- data.frame(
    role = factor(results$role_scores$role),
    adopted = factor(results$final_states)
  ) %>%
    group_by(role) %>%
    summarise(
      n = n(),
      adopted = sum(as.numeric(as.character(adopted))),
      proportion = adopted/n
    )
  
  # 4. Análisis de bloques estructurales
  node_cohesion <- data.frame(
    node = 1:length(results$final_metrics$clustering_effect),
    cohesion = results$final_metrics$clustering_effect
  )
  
  block_adoption <- data.frame(
    node = 1:length(results$final_states),
    block = ifelse(1:length(results$final_states) <= nrow(org_attributes),
                   as.character(org_attributes$block), "Unknown"),
    adopted = results$final_states
  ) %>%
    left_join(node_cohesion, by = "node") %>%
    group_by(block) %>%
    summarise(
      adoption_rate = mean(adopted),
      cohesion = mean(cohesion, na.rm = TRUE)
    )
  
  # 5. Visualizaciones
  p1 <- ggplot(df_total, aes(x = iteration, y = proportion)) +
    geom_line(size = 1.2, color = "#2C3E50") +
    geom_point(size = 3, color = "#E74C3C") +
    geom_line(aes(y = exposure), linetype = "dashed", color = "#8E44AD") +
    theme_minimal() +
    labs(
      title = "Difusión Global y Exposición",
      subtitle = sprintf("Adopción final: %.1f%%", 
                         results$final_metrics$adoption_rate * 100),
      x = "Iteración",
      y = "Proporción"
    ) +
    scale_y_continuous(
      labels = scales::percent_format(),
      limits = c(0, 1)
    )
  
  p2 <- ggplot(df_by_type, aes(x = iteration, y = proportion, color = tipo)) +
    geom_line(size = 1.2) +
    geom_point(size = 2) +
    theme_minimal() +
    labs(
      title = "Difusión por Tipo de Organización",
      x = "Iteración",
      y = "Proporción Adoptante",
      color = "Tipo de Organización"
    ) +
    scale_y_continuous(
      labels = scales::percent_format(),
      limits = c(0, 1)
    ) +
    scale_color_viridis_d() + 
    theme(legend.position = "none")
  
  p3 <- ggplot(role_adoption, 
               aes(x = reorder(role, proportion), y = proportion)) +
    geom_bar(stat = "identity", fill = "#2C3E50", alpha = 0.8) +
    geom_text(aes(label = scales::percent(proportion)), 
              position = position_stack(vjust = 0.5),
              color = "white") +
    theme_minimal() +
    labs(
      title = "Adopción Final por Rol Estructural",
      x = "Rol",
      y = "Proporción Adoptante"
    ) +
    scale_y_continuous(labels = scales::percent_format()) +
    theme(
      plot.title = element_text(face = "bold", size = 14),
      axis.title = element_text(size = 11),
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
  
  p4 <- ggplot(block_adoption, aes(x = cohesion, y = adoption_rate)) +
    geom_point(size = 3, color = "#E74C3C") +
    geom_smooth(method = "lm", se = FALSE, color = "#2C3E50") +
    theme_minimal() +
    labs(
      title = "Adopción vs Cohesión por Bloque Estructural",
      x = "Cohesión Estructural del Bloque",
      y = "Tasa de Adopción del Bloque"
    )
  
  # 6. Combinar visualizaciones
  layout <- "
  AB
  CD
  "
  
  combined_plot <- p1 + p2 + p3 + p4 +
    plot_layout(design = layout) +
    plot_annotation(
      title = "Análisis de Difusión de Comportamiento Conflictivo",
      subtitle = sprintf("Iteraciones: %d | Convergencia en: %.1f%% de adopción", 
                         results$n_iterations,
                         results$final_metrics$adoption_rate * 100),
      theme = theme(
        plot.title = element_text(size = 16, face = "bold"),
        plot.subtitle = element_text(size = 12)
      )
    )
  
  return(combined_plot)
}
```

### Ejecutar funciones  

#### Resultados heterogeneous thresholds = FALSE
```{r}
# Ejecutar una simulación
results <- improved_diffusion_v9(
  networks = networks,
  attributes = org_attributes,
  seeds = which(org_attributes$tipo == " Organización política de pobladores "),
  use_heterogeneous_thresholds = FALSE
)

# Visualizar resultados
plot_diffusion_results_v2(results, org_attributes)
```

#### Resultados heterogeneous thresholds = TRUE
```{r}
# Ejecutar una simulación
results <- improved_diffusion_v9(
  networks = networks,
  attributes = org_attributes,
  seeds = which(org_attributes$tipo == " Organización política de pobladores "),
  use_heterogeneous_thresholds = TRUE
)

# Visualizar resultados
plot_diffusion_results_v2(results, org_attributes)
```


This suggests:

- Complex contagion varies by organizational type
- Structural position moderates adoption thresholds
- Identity transformation requires both exposure and capacity


### Simulaciones heterogeneous thresholds = TRUE
```{r}
# Función para ejecutar múltiples simulaciones
run_multiple_simulations <- function(networks, attributes, seeds, n_sims = 100) {
  results_list <- list()
  for(i in 1:n_sims) {
    results_list[[i]] <- improved_diffusion_v9(
      networks = networks,
      attributes = attributes,
      seeds = seeds
    )
  }
  
  # Calcular estadísticas agregadas
  adoption_rates <- sapply(results_list, function(x) x$final_metrics$adoption_rate)
  iterations <- sapply(results_list, function(x) x$n_iterations)
  
  return(list(
    mean_adoption = mean(adoption_rates),
    sd_adoption = sd(adoption_rates),
    mean_iterations = mean(iterations),
    sd_iterations = sd(iterations),
    results = results_list
  ))
}


# O ejecutar múltiples simulaciones
multiple_results <- run_multiple_simulations(
  networks = networks,
  attributes = org_attributes,
  seeds = which(org_attributes$tipo == " Organización política de pobladores "),
  n_sims = 100
)

# Análisis de la infomracióm simulada
mean_adoption_rate <- multiple_results$mean_adoption
sd_adoption_rate <- multiple_results$sd_adoption

cat("La tasa de adopción final promedio es:", round(mean_adoption_rate * 100, 2), "%\n")
cat("La desviación estándar de la tasa de adopción final es:", round(sd_adoption_rate * 100, 2), "%\n")

## Trayectorias simuladas
diffusion_trajectories <- lapply(seq_along(multiple_results$results), function(i) {
  data.frame(
    iteration = seq_along(multiple_results$results[[i]]$final_metrics$change_trajectory),
    adoption_rate = multiple_results$results[[i]]$final_metrics$change_trajectory,
    simulation = paste("Simulación", i)
  )
})

diffusion_trajectories <- do.call(rbind, diffusion_trajectories)

ggplot(diffusion_trajectories, aes(x = iteration, y = adoption_rate, color = simulation)) +
  geom_line() +
  labs(x = "Iteración", y = "Tasa de Adopción") +
  ggtitle("Trayectorias de Difusión") +
  theme_minimal() +
  theme(legend.position = "none")


## Adopción por tipo y rol
adoption_by_type <- lapply(multiple_results$results, function(x) x$final_metrics$adoption_by_type)
adoption_by_role <- lapply(multiple_results$results, function(x) x$final_metrics$adoption_by_role)

mean_adoption_by_type <- Reduce("+", adoption_by_type) / length(adoption_by_type)
mean_adoption_by_role <- Reduce("+", adoption_by_role) / length(adoption_by_role)

print("Adopción promedio por tipo de organización:")
print(mean_adoption_by_type)

print("Adopción promedio por rol estructural:")
print(mean_adoption_by_role)

## Adopción y centralidad 
centrality_measures <- lapply(multiple_results$results, function(x) x$centrality_measures)
clustering_effects <- lapply(multiple_results$results, function(x) x$final_metrics$clustering_effect)

# Ejemplo: Correlación promedio entre centralidad de grado y adopción final
cor_degree_adoption <- sapply(seq_along(centrality_measures), function(i) {
  degree_centrality <- centrality_measures[[i]]$degree
  adoption_status <- multiple_results$results[[i]]$final_states
  cor(degree_centrality, adoption_status)
})

mean_cor_degree_adoption <- mean(cor_degree_adoption)
cat("Correlación promedio entre centralidad de grado y adopción final:", round(mean_cor_degree_adoption, 2), "\n")


# Asumiendo que ejecutaste múltiples simulaciones con diferentes parámetros y los resultados están en `multiple_results`
mean_adoption_rates <- sapply(multiple_results$results, function(x) x$final_metrics$adoption_rate)
plot(mean_adoption_rates, xlab = "Simulación", ylab = "Tasa de Adopción Final", main = "Análisis de Sensibilidad")
```



## Relaciones múltiples 

```{r}
# Análisis de tipos de vínculos por organización
analyze_tie_types <- function(networks, org_id) {
  # Contar en cuántas redes diferentes tiene vínculos la organización
  tie_count <- sum(sapply(networks, function(net) any(net[org_id,] > 0 | net[,org_id] > 0)))
  return(tie_count)
}

# Aplicar a todas las organizaciones
tie_types <- sapply(1:nrow(networks[[1]]), function(i) analyze_tie_types(networks, i))

# Cruzar con resultados de adopción
adoption_by_tie_types <- tapply(results$final_states, tie_types, mean)
adoption_by_tie_types
```


Esto significa que:

- Organizaciones con 0 tipos de vínculos: 0% de adopción
- Organizaciones con 2 tipos de vínculos: 0% de adopción
- Organizaciones con 3 tipos de vínculos: 25% de adopción
- Organizaciones con 4 tipos de vínculos: 46.15% de adopción

Este es un hallazgo importante que muestra:

- Efecto escalonado de la multiplexidad: Hay un claro patrón donde más tipos de vínculos llevan a mayor probabilidad de adopción.
- Umbral crítico: Parece haber un umbral importante en 3 vínculos, donde comienza a verse adopción.
- Máximo efecto: Las organizaciones con 4 tipos de vínculos tienen casi el doble de probabilidad de adopción que las que tienen 3 tipos.
- This supports Centola & Macy's (2007) complex contagion theory while adding crucial nuance about tie multiplexity.
- These findings extend Baldassarri & Diani's (2007) network integration theory by showing how different types of ties interact to produce qualitatively different outcomes.



```{r}
# 1. Número de organizaciones por categoría de vínculos
table(tie_types)

# 2. Para cada categoría, analizar qué tipos de vínculos tienen
analyze_link_types <- function(networks, org_id) {
  # Ver qué tipos de redes tienen vínculos
  types <- sapply(1:length(networks), function(n) {
    any(networks[[n]][org_id,] > 0 | networks[[n]][,org_id] > 0)
  })
  return(types)
}

# Aplicar para todas las organizaciones
org_link_patterns <- t(sapply(1:nrow(networks[[1]]), function(i) 
  analyze_link_types(networks, i)))

# Agrupar por número de vínculos y ver patrones comunes
link_patterns_by_count <- split(
  data.frame(org_link_patterns), 
  tie_types
)

# Ver también los tipos de organizaciones en cada categoría
org_types_by_links <- split(
  org_attributes$tipo,
  tie_types
)

#org_types_by_links
```

```{r}
# 1. Distribución de multiplexidad por tipo de organización
ggplot(data.frame(
  tipo = unlist(org_types_by_links),
  vinculos = rep(c(0,2,3,4), sapply(org_types_by_links, length))
)) +
  geom_bar(aes(x = tipo, fill = factor(vinculos)), position = "fill") +
  scale_fill_viridis_d(name = "Número de\nvínculos") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Distribución de Multiplexidad por Tipo Organizacional",
       x = "Tipo de Organización",
       y = "Proporción")

```


The distribution of multiplex ties reveals clear organizational patterns. Political organizations and housing committees show consistently high levels of multiplexity, while neighborhood organizations display a bimodal pattern.


#### Polarized Distribution:

- Most organizations either have maximum connectivity (4 ties) or minimal connectivity (0 ties)
- Political organizations consistently maintain multiple ties
- Neighborhood organizations show bimodal distribution


#### Organizational Capacity:

- 100% of political base organizations have 4 ties
- 100% of housing committees have 4 ties
- Cultural organizations show mixed patterns

[Quote opportunity: Discussing organizational differences in maintaining relationships]

```{r}
# 2. Tasa de adopción por nivel de multiplexidad
ggplot(data.frame(
  vinculos = factor(c(0,2,3,4)),
  adopcion = c(0, 0, 0.25, 0.4615385)
)) +
  geom_bar(aes(x = vinculos, y = adopcion, fill = adopcion), 
           stat = "identity") +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(title = "Tasa de Adopción por Nivel de Multiplexidad",
       x = "Número de Vínculos",
       y = "Tasa de Adopción")
```



The relationship between multiple ties and adoption shows a clear threshold effect. Organizations with fewer than three types of ties show no adoption, while those with four types of ties show the highest adoption rates (46.15%).


```{r}
# 3. Composición de grupos por multiplexidad
ggplot(data.frame(
  vinculos = rep(c(0,2,3,4), sapply(org_types_by_links, length)),
  count = 1
)) +
  geom_bar(aes(x = factor(vinculos), fill = factor(vinculos))) +
  scale_fill_viridis_d() +
  theme_minimal() +
  labs(title = "Número de Organizaciones por Nivel de Multiplexidad",
       x = "Número de Vínculos",
       y = "Cantidad de Organizaciones")
```


The structural composition of the network shows a polarized pattern, with most organizations either having no multiple ties (10 organizations) or the maximum number of ties (52 organizations), suggesting a core-periphery structure in the movement network.

[*Quote opportunity: Leader discussing how different types of relationships combined in practice*]



## Discusión

Este modelo incorpora varios elementos teóricos clave:

1. **Multiplexidad de vínculos**: Considera cinco tipos de relaciones con diferentes pesos según su importancia teórica para la difusión de identidades políticas.

2. **Roles estructurales**: Identifica brokers y organizaciones núcleo usando una combinación de medidas de centralidad y multiplexidad.

3. **Umbrales heterogéneos**: Aplica diferentes umbrales de adopción según el tipo de organización, reflejando su propensión a adoptar posturas contenciosas.

4. **Mecanismos de influencia**: 
   - Efecto directo de vínculos múltiples
   - Bonus por tipo de vínculo (confianza y valores)
   - Efectos de rol estructural (brokers y cores)
   
5. **Complex contagion**: Requiere exposición múltiple y considera la estructura local de la red.

Los resultados sugieren que:

1. Las organizaciones políticas de pobladores actúan como núcleo efectivo del proceso de difusión.
2. La multiplexidad de vínculos acelera la adopción.
3. Existen umbrales críticos que varían por tipo organizativo.
4. Los brokers juegan un rol clave en conectar diferentes dominios organizativos.


# References

Baldassarri, D., & Diani, M. (2007). The integrative power of civic networks. American Journal of Sociology, 113(3), 735-780.

Centola, D. (2018). How behavior spreads: The science of complex contagions. Princeton University Press.

Centola, D., & Macy, M. (2007). Complex contagions and the weakness of long ties. American Journal of Sociology, 113(3), 702-734.

Diani, M. (2003). Networks and social movements: A research programme. In M. Diani & D. McAdam (Eds.), Social movements and networks: Relational approaches to collective action (pp. 299-319). Oxford University Press.

Diani, M. (2015). The cement of civil society. Cambridge University Press.

Domínguez, S., & Hollstein, B. (2014). Mixed methods social networks research: Design and applications. Cambridge University Press.

Gould, R. V. (1991). Multiple networks and mobilization in the Paris Commune, 1871. American Sociological Review, 56(6), 716-729.

McAdam, D., & Paulsen, R. (1993). Specifying the relationship between social ties and activism. American Journal of Sociology, 99(3), 640-667.

McAdam, D., Tarrow, S., & Tilly, C. (2001). Dynamics of contention. Cambridge University Press.

Mische, A. (2003). Cross-talk in movements: Reconceiving the culture-network link. In M. Diani & D. McAdam (Eds.), Social movements and networks: Relational approaches to collective action (pp. 258-280). Oxford University Press.

Passy, F., & Giugni, M. (2001). Social networks and individual perceptions: Explaining differential participation in social movements. Sociological Forum, 16(1), 123-153.

Scott, J. (2011). Social network analysis: Developments, advances, and prospects. Social Network Analysis and Mining, 1(1), 21-26.

Tarrow, S. (2005). The new transnational activism. Cambridge University Press.

Tilly, C. (2004). Social boundary mechanisms. Philosophy of the Social Sciences, 34(2), 211-236.

Tilly, C., & Tarrow, S. (2015). Contentious politics (2nd ed.). Oxford University Press.

